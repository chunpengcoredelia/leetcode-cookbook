<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>字符串专题</title>
  <meta name="description" content="字符串专题" />
  <meta name="generator" content="bookdown 0.19 and GitBook 2.6.7" />

  <meta property="og:title" content="字符串专题" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="字符串专题" />
  
  
  

<meta name="author" content="高文欣" />


<meta name="date" content="2021-08-31" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/header-attrs-2.2/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path=""><a href="#字符串专题"><i class="fa fa-check"></i><b>1</b> 字符串专题</a>
<ul>
<li class="chapter" data-level="1.1" data-path=""><a href="#反转字符串一"><i class="fa fa-check"></i><b>1.1</b> 反转字符串一</a></li>
<li class="chapter" data-level="1.2" data-path=""><a href="#反转字符串二"><i class="fa fa-check"></i><b>1.2</b> 反转字符串二</a></li>
<li class="chapter" data-level="1.3" data-path=""><a href="#无重复字符的最长子串"><i class="fa fa-check"></i><b>1.3</b> 无重复字符的最长子串</a></li>
<li class="chapter" data-level="1.4" data-path=""><a href="#替换空格"><i class="fa fa-check"></i><b>1.4</b> 替换空格</a></li>
<li class="chapter" data-level="1.5" data-path=""><a href="#反转字符串里面的单词"><i class="fa fa-check"></i><b>1.5</b> 反转字符串里面的单词</a></li>
<li class="chapter" data-level="1.6" data-path=""><a href="#左旋字符串"><i class="fa fa-check"></i><b>1.6</b> 左旋字符串</a></li>
<li class="chapter" data-level="1.7" data-path=""><a href="#最小覆盖字串"><i class="fa fa-check"></i><b>1.7</b> 最小覆盖字串</a></li>
<li class="chapter" data-level="1.8" data-path=""><a href="#字符串转换整数"><i class="fa fa-check"></i><b>1.8</b> 字符串转换整数</a></li>
<li class="chapter" data-level="1.9" data-path=""><a href="#最长公共前缀"><i class="fa fa-check"></i><b>1.9</b> 最长公共前缀</a></li>
<li class="chapter" data-level="1.10" data-path=""><a href="#重复的子字符串"><i class="fa fa-check"></i><b>1.10</b> 重复的子字符串</a></li>
<li class="chapter" data-level="1.11" data-path=""><a href="#z形树或者n形树问题"><i class="fa fa-check"></i><b>1.11</b> z形树或者N形树问题</a></li>
<li class="chapter" data-level="1.12" data-path=""><a href="#连续字符串计数"><i class="fa fa-check"></i><b>1.12</b> 连续字符串计数</a></li>
<li class="chapter" data-level="1.13" data-path=""><a href="#滑动窗口模版"><i class="fa fa-check"></i><b>1.13</b> 滑动窗口模版</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">字符串专题</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="header">
<h1 class="title">字符串专题</h1>
<p class="author"><em>高文欣</em></p>
<p class="date"><em>2021-08-31</em></p>
</div>
<div id="字符串专题" class="section level1" number="1">
<h1><span class="header-section-number">1</span> 字符串专题</h1>
<div id="反转字符串一" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> 反转字符串一</h2>
<ul>
<li>题目描述</li>
</ul>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：
输入：[“h”,“e”,“l”,“l”,“o”]
输出：[“o”,“l”,“l”,“e”,“h”]</p>
<p>示例 2：
输入：[“H”,“a”,“n”,“n”,“a”,“h”]
输出：[“h”,“a”,“n”,“n”,“a”,“H”]</p>
<ul>
<li>解题思路</li>
</ul>
<p>其实一个库函数就能完成的reverse or [::-1]，但是不能这样</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>class Solution<span class="op">:</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="st">    </span>def <span class="kw">reverseString</span>(self, s<span class="op">:</span><span class="st"> </span>List[str]) -&gt;<span class="st"> </span>None<span class="op">:</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="st">        Do not return anything, modify s in-place instead.</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>        left, right =<span class="st"> </span><span class="dv">0</span>, <span class="kw">len</span>(s) <span class="op">-</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>        <span class="cf">while</span>(left <span class="op">&lt;</span><span class="st"> </span>right)<span class="op">:</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="st">            </span>s[left], s[right] =<span class="st"> </span>s[right], s[left]</span>
<span id="cb1-9"><a href="#cb1-9"></a>            left <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>            right <span class="op">-</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        return s</span></code></pre></div>
</div>
<div id="反转字符串二" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> 反转字符串二</h2>
<ul>
<li>题目描述</li>
</ul>
<p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的<strong>每隔 2k 个字符的前 k 个字符进行反转。</strong></p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s = “abcdefg”, k = 2
输出: “bacdfeg”</p>
<ul>
<li>解题思路</li>
</ul>
<p>每隔2k个字符反转，某年天眼查的面试题，根基还是反转字符串</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a></span>
<span id="cb2-2"><a href="#cb2-2"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="st">    </span>def <span class="kw">reverseStr</span>(self, s, k)<span class="op">:</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="st">        </span>from functools import reduce</span>
<span id="cb2-5"><a href="#cb2-5"></a>        s =<span class="st"> </span><span class="kw">list</span>(s) <span class="co"># 先把字符串变成list</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>        <span class="co"># a另一种方法 a[::-1]</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>        def <span class="kw">reverse</span>(s)<span class="op">:</span><span class="st"> </span><span class="co"># 这个就是反转字符串</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="st">            </span>left, right =<span class="st"> </span><span class="dv">0</span>, <span class="kw">len</span>(s) <span class="op">-</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>            <span class="cf">while</span> left <span class="op">&lt;</span><span class="st"> </span>right<span class="op">:</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="st">                </span>s[left], s[right] =<span class="st"> </span>s[right], s[left]</span>
<span id="cb2-11"><a href="#cb2-11"></a>                left <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>                right <span class="op">-</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>            return s</span>
<span id="cb2-14"><a href="#cb2-14"></a>        </span>
<span id="cb2-15"><a href="#cb2-15"></a>        <span class="co"># make sure we reverse each 2k elements </span></span>
<span id="cb2-16"><a href="#cb2-16"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">0</span>, <span class="kw">len</span>(s), <span class="dv">2</span><span class="op">*</span>k)<span class="op">:</span><span class="st"> </span><span class="co"># 选择条件是每隔2k个</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="st">            </span>s[i<span class="op">:</span>(i<span class="op">+</span>k)] =<span class="st"> </span><span class="kw">reverse</span>(s[i<span class="op">:</span>(i<span class="op">+</span>k)]) <span class="co"># 递归</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>        </span>
<span id="cb2-19"><a href="#cb2-19"></a>        <span class="co"># combine list into str.</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>        return <span class="kw">reduce</span>(lambda a, b<span class="op">:</span><span class="st"> </span>a<span class="op">+</span>b, s) <span class="co"># 最后拼成字符串</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>        </span>
<span id="cb2-22"><a href="#cb2-22"></a></span></code></pre></div>
</div>
<div id="无重复字符的最长子串" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> 无重复字符的最长子串</h2>
<p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
<p>示例1:</p>
<p>输入: “abcabcbb”
输出: 3
解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。
示例 2:</p>
<p>输入: “bbbbb”
输出: 1
解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。
示例 3:</p>
<p>输入: “pwwkew”
输出: 3
解释: 因为无重复字符的最长子串是“wke”，所以其长度为 3。
请注意，你的答案必须是子串的长度，“pwke”是一个子序列，不是子串。</p>
<p><strong>分析</strong>：切割大法好</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>class Solution<span class="op">:</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="st">    </span>def <span class="kw">lengthOfLongestSubstring</span>(self, s<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="st">        </span>L =<span class="st"> </span>[] <span class="co"># 定义一个空的列表用来存字串</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>        lenth =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>        <span class="cf">for</span> i <span class="cf">in</span> s<span class="op">:</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="st">            </span><span class="co">#如果字符不在列表中，追加该字符并计算列表长度</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="st">            </span><span class="cf">if</span> i not <span class="cf">in</span> L<span class="op">:</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="st">                </span><span class="kw">L.append</span>(i)</span>
<span id="cb3-9"><a href="#cb3-9"></a>            <span class="co">#如果字符在列表中，从字符所在位置切分列表</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="st">                </span>idx =<span class="st"> </span><span class="kw">L.index</span>(i) <span class="co"># 获得索引的一种方式</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>                L =<span class="st"> </span>L[idx<span class="op">+</span><span class="dv">1</span><span class="op">:</span>]</span>
<span id="cb3-13"><a href="#cb3-13"></a>                <span class="kw">L.append</span>(i)<span class="co">#切分之后将字符追加入列表</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>            current =<span class="st"> </span><span class="kw">len</span>(L)</span>
<span id="cb3-15"><a href="#cb3-15"></a>            lenth =<span class="st"> </span><span class="kw">max</span>(current,lenth)</span>
<span id="cb3-16"><a href="#cb3-16"></a>        return lenth</span></code></pre></div>
</div>
<div id="替换空格" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> 替换空格</h2>
<ul>
<li>题目描述</li>
</ul>
<p>请实现一个函数，把字符串 s 中的每个空格替换成“%20”。</p>
<p>示例 1： 输入：s = “We are happy.”
输出：“We%20are%20happy.”</p>
<ul>
<li>解题思路</li>
</ul>
<p>其实一个replace就能搞定，但是不能这么干</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>class Solution<span class="op">:</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="st">    </span><span class="co"># s 源字符串</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="st">    </span>def <span class="kw">replaceSpace</span>(self, s)<span class="op">:</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="st">        </span>s =<span class="st"> </span><span class="kw">list</span>(s)</span>
<span id="cb4-7"><a href="#cb4-7"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(s))<span class="op">:</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="st">            </span><span class="cf">if</span> s[i] <span class="op">==</span><span class="st"> &#39; &#39;</span><span class="op">:</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="st">                </span>s[i] =<span class="st"> &#39;%20&#39;</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>        return <span class="st">&#39;&#39;</span><span class="kw">.join</span>(s)</span></code></pre></div>
</div>
<div id="反转字符串里面的单词" class="section level2" number="1.5">
<h2><span class="header-section-number">1.5</span> 反转字符串里面的单词</h2>
<ul>
<li>题目描述
给定一个字符串，逐个翻转字符串中的每个单词。</li>
</ul>
<p>示例 1：
输入: “the sky is blue”
输出: “blue is sky the”</p>
<p>示例 2：
输入: " hello world! "
输出: “world! hello”
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：
输入: “a good example”
输出: “example good a”
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>只是交换单词的顺序，但是单词还是原来的单词</p>
<ul>
<li>解题思路</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>class Solution<span class="op">:</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="st">    </span>def <span class="kw">reverseWords</span>(self, s<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>str<span class="op">:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="st">        </span>return <span class="st">&quot; &quot;</span><span class="kw">.join</span>(<span class="kw">s.strip</span>()<span class="kw">.split</span>()[<span class="op">::-</span><span class="dv">1</span>])   </span></code></pre></div>
</div>
<div id="左旋字符串" class="section level2" number="1.6">
<h2><span class="header-section-number">1.6</span> 左旋字符串</h2>
<ul>
<li>题目描述</li>
</ul>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串“abcdefg”和数字2，该函数将返回左旋转两位得到的结果“cdefgab”。</p>
<p>示例 1：
输入: s = “abcdefg”, k = 2
输出: “cdefgab”</p>
<p>示例 2：
输入: s = “lrloseumgh”, k = 6
输出: “umghlrlose”</p>
<p>限制：
1 &lt;= k &lt; s.length &lt;= 10000</p>
<p>限制条件，不额外开辟空间</p>
<ul>
<li>解题思路</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>class Solution<span class="op">:</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="st">    </span>def <span class="kw">reverseLeftWords</span>(self, s<span class="op">:</span><span class="st"> </span>str, n<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>str<span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="st">        </span>return s[n<span class="op">:</span>] <span class="op">+</span><span class="st"> </span>s[<span class="dv">0</span><span class="op">:</span>n]</span>
<span id="cb6-4"><a href="#cb6-4"></a>    </span></code></pre></div>
</div>
<div id="最小覆盖字串" class="section level2" number="1.7">
<h2><span class="header-section-number">1.7</span> 最小覆盖字串</h2>
<ul>
<li>题目描述
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。</li>
</ul>
<p>示例 1：</p>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”
输出：“BANC”
示例 2：</p>
<p>输入：s = “a”, t = “a”
输出：“a”
示例 3:</p>
<p>输入: s = “a”, t = “aa”
输出: ""
解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。</p>
<ul>
<li>解题思路</li>
</ul>
<p>滑动窗口</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>class Solution<span class="op">:</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="st">    </span>def <span class="kw">minWindow</span>(self, s<span class="op">:</span><span class="st"> </span>str, t<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>str<span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="st">        </span>need =<span class="st"> </span><span class="kw">collections.defaultdict</span>(int) <span class="co"># 记录t中字符出现次数</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>        window =<span class="st"> </span><span class="kw">collections.defaultdict</span>(int) <span class="co"># 记录窗口中响应的字符出现的次数</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>        <span class="cf">for</span> c <span class="cf">in</span> t<span class="op">:</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="st">            </span>need[c] <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>        </span>
<span id="cb7-8"><a href="#cb7-8"></a>        left,right =<span class="st"> </span><span class="dv">0</span>,<span class="dv">0</span> <span class="co"># 初始窗口长度为0</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>        valid =<span class="st"> </span><span class="dv">0</span> <span class="co"># 用于记录window中t中字符是否出现完，比如：t=&#39;abc&#39;，window=&#39;abd&#39;,valid就等于2.代表need中应该出现的字符在window中才出现了两个，还没有出现完全</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a>        <span class="co"># 记录最小覆盖子串的起始索引及长度</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>        start =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>        length =<span class="st"> </span><span class="kw">len</span>(s) <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a>        <span class="cf">while</span> right <span class="op">&lt;</span><span class="st"> </span><span class="kw">len</span>(s)<span class="op">:</span></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="st">            </span>c =<span class="st"> </span>s[right] <span class="co"># 即将加入window的字符c</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>            right <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span> <span class="co"># 右移窗口</span></span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a>            <span class="co"># 窗口内数据的一系列更新</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>            <span class="cf">if</span> c <span class="cf">in</span> need<span class="op">:</span></span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="st">                </span>window[c] <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>                <span class="cf">if</span> window[c] <span class="op">==</span><span class="st"> </span>need[c]<span class="op">:</span><span class="st"> </span><span class="co"># window中字符c出现的次数已经达到need所需要的次数时，valid进行更新</span></span>
<span id="cb7-23"><a href="#cb7-23"></a><span class="st">                    </span>valid <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb7-24"><a href="#cb7-24"></a></span>
<span id="cb7-25"><a href="#cb7-25"></a>            <span class="co"># 判断窗口左侧边界是否要收缩</span></span>
<span id="cb7-26"><a href="#cb7-26"></a>            <span class="cf">while</span> valid <span class="op">==</span><span class="st"> </span><span class="kw">len</span>(need)<span class="op">:</span></span>
<span id="cb7-27"><a href="#cb7-27"></a><span class="st">                </span><span class="co"># 在这里更新最小覆盖子串</span></span>
<span id="cb7-28"><a href="#cb7-28"></a><span class="st">                </span><span class="cf">if</span> right<span class="op">-</span>left <span class="op">&lt;</span><span class="st"> </span>length<span class="op">:</span></span>
<span id="cb7-29"><a href="#cb7-29"></a><span class="st">                    </span>start =<span class="st"> </span>left</span>
<span id="cb7-30"><a href="#cb7-30"></a>                    length =<span class="st"> </span>right<span class="op">-</span>left</span>
<span id="cb7-31"><a href="#cb7-31"></a></span>
<span id="cb7-32"><a href="#cb7-32"></a>                <span class="co"># d是将移出窗口的字符</span></span>
<span id="cb7-33"><a href="#cb7-33"></a>                d =<span class="st"> </span>s[left]</span>
<span id="cb7-34"><a href="#cb7-34"></a>                <span class="co"># 左移窗口</span></span>
<span id="cb7-35"><a href="#cb7-35"></a>                left <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb7-36"><a href="#cb7-36"></a>                <span class="co"># 进行窗口内数据的一系列更新</span></span>
<span id="cb7-37"><a href="#cb7-37"></a>                <span class="cf">if</span> d <span class="cf">in</span> need<span class="op">:</span></span>
<span id="cb7-38"><a href="#cb7-38"></a><span class="st">                    </span><span class="cf">if</span> window[d] <span class="op">==</span><span class="st"> </span>need[d]<span class="op">:</span><span class="st"> </span><span class="co"># 这句话和下面的window[c]-=1不能反，先判断删去的字符c的数量是不是满足need的数量，如果满足，valid将减去1。</span></span>
<span id="cb7-39"><a href="#cb7-39"></a><span class="st">                        </span>valid <span class="op">-</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb7-40"><a href="#cb7-40"></a>                    window[d] <span class="op">-</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb7-41"><a href="#cb7-41"></a>        <span class="co"># 返回最小覆盖子串</span></span>
<span id="cb7-42"><a href="#cb7-42"></a>        <span class="cf">if</span> length <span class="op">==</span><span class="st"> </span><span class="kw">len</span>(s) <span class="op">+</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb7-43"><a href="#cb7-43"></a><span class="st">            </span>return <span class="st">&#39;&#39;</span></span>
<span id="cb7-44"><a href="#cb7-44"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb7-45"><a href="#cb7-45"></a><span class="st">            </span>return s[start<span class="op">:</span>start<span class="op">+</span>length]</span></code></pre></div>
</div>
<div id="字符串转换整数" class="section level2" number="1.8">
<h2><span class="header-section-number">1.8</span> 字符串转换整数</h2>
<ul>
<li>题目描述</li>
</ul>
<p>将字符串转化成为整数</p>
<p>例子
s=“1234”
转化后：ss=[1,2,3,4]</p>
<p>使用正则表达式：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="op">^</span><span class="st"> </span>匹配字符串开头</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a>[\<span class="op">+</span>\<span class="op">-</span>] 代表一个<span class="op">+</span>字符或<span class="op">-</span>字符</span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a>? 前面一个字符可有可无</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a>\d 一个数字</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="op">+</span><span class="st"> </span>前面一个字符的一个或多个</span>
<span id="cb8-11"><a href="#cb8-11"></a></span>
<span id="cb8-12"><a href="#cb8-12"></a>\D 一个非数字字符</span>
<span id="cb8-13"><a href="#cb8-13"></a></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="op">*</span><span class="st"> </span>前面一个字符的0个或多个</span>
<span id="cb8-15"><a href="#cb8-15"></a></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="kw">max</span>(<span class="kw">min</span>(数字, <span class="dv">2</span><span class="op">**</span><span class="dv">31</span> <span class="op">-</span><span class="st"> </span><span class="dv">1</span>), <span class="dv">-2</span><span class="op">**</span><span class="dv">31</span>) 用来防止结果越界</span></code></pre></div>
<p>为什么可以使用正则表达式？如果整数过大溢出怎么办？</p>
<p>题目中描述： 假设我们的环境只能存储 32 位大小的有符号整数</p>
<p>首先，这个假设对于 Python 不成立，Python 不存在 32 位的 int 类型。其次，即使搜索到的字符串转32位整数可能导致溢出，我们也可以直接通过字符串判断是否存在溢出的情况（比如 try 函数 或 判断字符串长度 + 字符串比较），</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>class Solution<span class="op">:</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="st">    </span>def <span class="kw">myAtoi</span>(self, s<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="st">        </span>return <span class="kw">max</span>(<span class="kw">min</span>(<span class="kw">int</span>(<span class="op">*</span><span class="kw">re.findall</span>(<span class="st">&#39;^[\+\-]?\d+&#39;</span>, <span class="kw">s.lstrip</span>())), <span class="dv">2</span><span class="op">**</span><span class="dv">31</span> <span class="op">-</span><span class="st"> </span><span class="dv">1</span>), <span class="dv">-2</span><span class="op">**</span><span class="dv">31</span>)</span></code></pre></div>
<p>正则真的好方便啊啊啊啊~</p>
</div>
<div id="最长公共前缀" class="section level2" number="1.9">
<h2><span class="header-section-number">1.9</span> 最长公共前缀</h2>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 ""。</p>
<p>示例 1:</p>
<p>输入: [“flower”,“flow”,“flight”]
输出: “fl”
示例 2:</p>
<p>输入: [“dog”,“racecar”,“car”]
输出: ""
解释: 输入不存在公共前缀。
说明:</p>
<p>所有输入只包含小写字母 a-z 。
- ascii 码思路，字母是可以比较大小的
&gt;利用python的max()和min()，在Python里字符串是可以比较的，按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>class Solution<span class="op">:</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="st">    </span>def <span class="kw">longestCommonPrefix</span>(self, strs<span class="op">:</span><span class="st"> </span>List[str]) -&gt;<span class="st"> </span>str<span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="st">        </span><span class="cf">if</span> not strs<span class="op">:</span><span class="st"> </span>return <span class="st">&quot;&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>        s1=<span class="kw">min</span>(strs)</span>
<span id="cb10-5"><a href="#cb10-5"></a>        s2=<span class="kw">max</span>(strs)</span>
<span id="cb10-6"><a href="#cb10-6"></a>        <span class="cf">for</span> k,v <span class="cf">in</span> <span class="kw">enumerate</span>(s1)<span class="op">:</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="st">            </span><span class="cf">if</span> v <span class="op">!=</span>s2[k]<span class="op">:</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="st">                </span>return s2[<span class="op">:</span>k]</span>
<span id="cb10-9"><a href="#cb10-9"></a>        return s1</span></code></pre></div>
<ul>
<li>解题思路2
使用 zip 根据字符串下标合并成数组，
判断合并后数组里元素是否都相同</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="st">    </span>def <span class="kw">longestCommonPrefix</span>(self, strs)<span class="op">:</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="st">        </span>ans =<span class="st"> &#39;&#39;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">zip</span>(<span class="op">*</span>strs)<span class="op">:</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="st">            </span><span class="cf">if</span> <span class="kw">len</span>(<span class="kw">set</span>(i)) <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="st">                </span>ans <span class="op">+</span><span class="er">=</span><span class="st"> </span>i[<span class="dv">0</span>]</span>
<span id="cb11-7"><a href="#cb11-7"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="st">                </span><span class="cf">break</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>        return ans</span></code></pre></div>
</div>
<div id="重复的子字符串" class="section level2" number="1.10">
<h2><span class="header-section-number">1.10</span> 重复的子字符串</h2>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:
输入: “abab”
输出: True
解释: 可由子字符串 “ab” 重复两次构成。</p>
<p>示例 2:
输入: “aba”
输出: False</p>
<p>示例 3:
输入: “abcabcabcabc”
输出: True
解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p>
<ul>
<li>解题思路</li>
</ul>
<p>第一眼看上去就是先找到字串，然后replace替换，剩下的字串为空即为true</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>s=<span class="st">&#39;abcabca&#39;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>m=<span class="st">&quot;&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="cf">for</span> i <span class="cf">in</span> s<span class="op">:</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="st">    </span><span class="cf">if</span> i not <span class="cf">in</span> m<span class="op">:</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="st">        </span>m<span class="op">+</span><span class="er">=</span>i</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="cf">if</span> <span class="kw">s.replace</span>(<span class="st">&#39;abc&#39;</span>,<span class="st">&#39;&#39;</span>)<span class="op">==</span><span class="st">&#39;&#39;</span><span class="op">:</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="st">    </span><span class="kw">print</span>(<span class="st">&#39;true&#39;</span>)</span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="cf">else</span><span class="op">:</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="st">    </span><span class="kw">print</span>(<span class="st">&#39;false&#39;</span>)</span></code></pre></div>
</div>
<div id="z形树或者n形树问题" class="section level2" number="1.11">
<h2><span class="header-section-number">1.11</span> z形树或者N形树问题</h2>
<ul>
<li>题目描述</li>
</ul>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a></span>
<span id="cb13-2"><a href="#cb13-2"></a>L   C   I   R</span>
<span id="cb13-3"><a href="#cb13-3"></a>E T O E S I I G</span>
<span id="cb13-4"><a href="#cb13-4"></a>E   D   H   N</span></code></pre></div>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p>string convert(string s, int numRows);
示例 1:</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 3
输出: “LCIRETOESIIGEDHN”
示例 2:</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4
输出: “LDREOEIIECIHNTSG”
解释:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>L     D     R</span>
<span id="cb14-2"><a href="#cb14-2"></a>E   O E   I I</span>
<span id="cb14-3"><a href="#cb14-3"></a>E C   I H   N</span>
<span id="cb14-4"><a href="#cb14-4"></a>T     S     G</span></code></pre></div>
<ul>
<li>解题思路：
题目理解:
。字符串 <span class="math inline">\(\quad s \quad\)</span> 是以 <span class="math inline">\(Z\)</span> 字形为顺序存储的字符串, 目标是按行打印。
<span class="math inline">\(\circ\)</span> 设 numRows 行字符串分别为 <span class="math inline">\(s_{1}, s_{2}, \ldots, s_{n},\)</span> 则容易发现：按顺序遍历字符串 <span class="math inline">\(s\)</span> 时, 每个字符 <span class="math inline">\(\quad\)</span> c 在 <span class="math inline">\(Z\)</span> 字形中对应的 行索引 先从 <span class="math inline">\(s_{1}\)</span> 增大至 <span class="math inline">\(s_{n},\)</span> 再从 <span class="math inline">\(s_{n}\)</span> 减小至 <span class="math inline">\(s_{1} \ldots \ldots\)</span> 如此反复。 因此, 解决方案为：模拟这个行索引的变化, 在遍历 <span class="math inline">\(s\)</span> 中把每个字符填到正确的行 res[i]
算法流程：按顺序遍历字符串 <span class="math inline">\(\quad s\)</span>;</li>
</ul>
<ol style="list-style-type: decimal">
<li>res[i] += c : 把每个字符 <span class="math inline">\(c\)</span> 填入对应行 <span class="math inline">\(s_{i}\)</span></li>
<li>i += flag : 更新当前字符 c 对应的行索引;</li>
<li>flag = - flag : 在达到 Z 字形转折点时，执行反向。
复杂度分析：
。时间复杂度 <span class="math inline">\(O(N):\)</span> 遍历一遍字符串 <span class="math inline">\(s\)</span>;
<span class="math inline">\(\circ\)</span> 空间复杂度 <span class="math inline">\(O(N):\)</span> 各行字符串共占用 <span class="math inline">\(O(N)\)</span> 额外空间。</li>
</ol>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a></span>
<span id="cb15-2"><a href="#cb15-2"></a>class Solution<span class="op">:</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="st">    </span>def <span class="kw">convert</span>(self, s<span class="op">:</span><span class="st"> </span>str, numRows<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>str<span class="op">:</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="st">        </span><span class="cf">if</span> numRows<span class="op">&lt;</span><span class="dv">2</span><span class="op">:</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="st">            </span>return s</span>
<span id="cb15-6"><a href="#cb15-6"></a>        res=[<span class="st">&quot;&quot;</span> <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(numRows)]</span>
<span id="cb15-7"><a href="#cb15-7"></a>        i,flag=<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>        <span class="cf">for</span> c <span class="cf">in</span> s<span class="op">:</span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="st">            </span>res[i] <span class="op">+</span><span class="er">=</span><span class="st"> </span>c</span>
<span id="cb15-10"><a href="#cb15-10"></a>            <span class="cf">if</span> i <span class="op">==</span><span class="dv">0</span> or i <span class="op">==</span><span class="st"> </span>numRows<span class="dv">-1</span><span class="op">:</span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="st">                </span>flag=<span class="op">-</span>flag</span>
<span id="cb15-12"><a href="#cb15-12"></a></span>
<span id="cb15-13"><a href="#cb15-13"></a>                i<span class="op">+</span><span class="er">=</span>flag</span>
<span id="cb15-14"><a href="#cb15-14"></a>            return <span class="st">&quot;&quot;</span><span class="kw">.join</span>(res)</span>
<span id="cb15-15"><a href="#cb15-15"></a></span></code></pre></div>
</div>
<div id="连续字符串计数" class="section level2" number="1.12">
<h2><span class="header-section-number">1.12</span> 连续字符串计数</h2>
<p>string = “aaabbcc”
输出：“ a3b2c2”</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a></span>
<span id="cb16-2"><a href="#cb16-2"></a>coded =<span class="st"> &#39;&#39;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="cf">while</span> string<span class="op">:</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="st">    </span>i =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="cf">while</span> i <span class="op">&lt;</span><span class="st"> </span><span class="kw">len</span>(string) and string[<span class="dv">0</span>] <span class="op">==</span><span class="st"> </span>string[i]<span class="op">:</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="st">        </span>i <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>    coded <span class="op">+</span><span class="er">=</span><span class="st"> </span>string[<span class="dv">0</span>]<span class="op">+</span><span class="kw">str</span>(i)</span>
<span id="cb16-8"><a href="#cb16-8"></a>    string =<span class="st"> </span>string[i<span class="op">:</span>]</span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="kw">print</span>(coded)</span></code></pre></div>
</div>
<div id="滑动窗口模版" class="section level2" number="1.13">
<h2><span class="header-section-number">1.13</span> 滑动窗口模版</h2>
<p>就感觉这个模板有点复杂</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>初始化窗口端点L，R，一般L为0，R为1</span>
<span id="cb17-2"><a href="#cb17-2"></a>    初始化最优值</span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="cf">while</span> R <span class="op">&lt;</span><span class="st"> </span><span class="kw">len</span>(Array)<span class="op">:</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="st">        </span><span class="cf">while</span> R <span class="op">&lt;</span><span class="st"> </span><span class="kw">len</span>(Array)<span class="op">:</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="st">            </span>R <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span>              <span class="co">#移动右端点</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>            <span class="cf">if</span> R <span class="op">&lt;</span><span class="st"> </span><span class="kw">len</span>(Array)<span class="op">:</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="st">                </span>更新状态        </span>
<span id="cb17-8"><a href="#cb17-8"></a>            <span class="cf">if</span> 状态满足条件<span class="op">:</span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="st">                </span>可选的更新最优值的位置</span>
<span id="cb17-10"><a href="#cb17-10"></a>                <span class="cf">break</span>           <span class="co">#一旦满足条件即跳出</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>        <span class="cf">if</span> R <span class="op">==</span><span class="st"> </span><span class="kw">len</span>(Array)<span class="op">:</span><span class="st">     </span><span class="co"># 若循环是由于移动到数组末尾结束，则停止整个程序。因为之后已经不再有可能的解</span></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="st">            </span><span class="cf">break</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>        <span class="cf">while</span> L <span class="op">&lt;</span><span class="st"> </span>R<span class="op">:</span></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="st">            </span>更新状态    <span class="co"># 移动左端点，需要更新状态</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>            L <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb17-16"><a href="#cb17-16"></a>            <span class="cf">if</span> 状态满足条件：</span>
<span id="cb17-17"><a href="#cb17-17"></a>                可选的更新最优值的位置</span>
<span id="cb17-18"><a href="#cb17-18"></a>            else：  <span class="co"># 一旦窗口所在区间不再满足条件即跳出，去移动右端点</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>                <span class="cf">break</span></span>
<span id="cb17-20"><a href="#cb17-20"></a>        可选的对于L，R端点的后续处理</span>
<span id="cb17-21"><a href="#cb17-21"></a>    return 最优值</span></code></pre></div>
<p>没有什么比理解题意直接套模版更爽的，字符串这里很多题会用到滑动窗口</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>

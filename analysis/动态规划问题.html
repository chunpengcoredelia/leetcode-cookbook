<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>动态规划专题</title>
  <meta name="description" content="动态规划专题" />
  <meta name="generator" content="bookdown 0.19 and GitBook 2.6.7" />

  <meta property="og:title" content="动态规划专题" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="动态规划专题" />
  
  
  

<meta name="author" content="高文欣" />


<meta name="date" content="2021-08-16" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/header-attrs-2.2/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path=""><a href="#动态规划问题"><i class="fa fa-check"></i><b>1</b> 动态规划问题</a>
<ul>
<li class="chapter" data-level="1.1" data-path=""><a href="#解题思路"><i class="fa fa-check"></i><b>1.1</b> 解题思路</a></li>
<li class="chapter" data-level="1.2" data-path=""><a href="#最大子序和问题"><i class="fa fa-check"></i><b>1.2</b> 最大子序和问题</a></li>
<li class="chapter" data-level="1.3" data-path=""><a href="#最长上升子序列"><i class="fa fa-check"></i><b>1.3</b> 最长上升子序列</a></li>
<li class="chapter" data-level="1.4" data-path=""><a href="#最短路径和问题"><i class="fa fa-check"></i><b>1.4</b> 最短路径和问题</a></li>
<li class="chapter" data-level="1.5" data-path=""><a href="#爬楼梯问题"><i class="fa fa-check"></i><b>1.5</b> 爬楼梯问题</a></li>
<li class="chapter" data-level="1.6" data-path=""><a href="#不同路径"><i class="fa fa-check"></i><b>1.6</b> 不同路径</a></li>
<li class="chapter" data-level="1.7" data-path=""><a href="#最长回文字符串"><i class="fa fa-check"></i><b>1.7</b> 最长回文字符串</a></li>
<li class="chapter" data-level="1.8" data-path=""><a href="#回文子字符串数量"><i class="fa fa-check"></i><b>1.8</b> 回文子字符串数量</a></li>
<li class="chapter" data-level="1.9" data-path=""><a href="#最大乘积和"><i class="fa fa-check"></i><b>1.9</b> 最大乘积和</a></li>
<li class="chapter" data-level="1.10" data-path=""><a href="#买卖股票专题"><i class="fa fa-check"></i><b>1.10</b> 买卖股票专题</a></li>
<li class="chapter" data-level="1.11" data-path=""><a href="#完全平方数"><i class="fa fa-check"></i><b>1.11</b> 完全平方数</a></li>
<li class="chapter" data-level="1.12" data-path=""><a href="#找零钱问题"><i class="fa fa-check"></i><b>1.12</b> 找零钱问题</a></li>
<li class="chapter" data-level="1.13" data-path=""><a href="#单词切分"><i class="fa fa-check"></i><b>1.13</b> 单词切分</a></li>
<li class="chapter" data-level="1.14" data-path=""><a href="#打家劫舍专题"><i class="fa fa-check"></i><b>1.14</b> 打家劫舍专题</a></li>
<li class="chapter" data-level="1.15" data-path=""><a href="#编辑距离"><i class="fa fa-check"></i><b>1.15</b> 编辑距离</a></li>
<li class="chapter" data-level="1.16" data-path=""><a href="#鸡蛋掉落"><i class="fa fa-check"></i><b>1.16</b> 鸡蛋掉落</a></li>
<li class="chapter" data-level="1.17" data-path=""><a href="#整数拆分"><i class="fa fa-check"></i><b>1.17</b> 整数拆分</a></li>
<li class="chapter" data-level="1.18" data-path=""><a href="#分割等和子集"><i class="fa fa-check"></i><b>1.18</b> 分割等和子集</a></li>
<li class="chapter" data-level="1.19" data-path=""><a href="#最长公共子序列"><i class="fa fa-check"></i><b>1.19</b> 最长公共子序列</a></li>
<li class="chapter" data-level="1.20" data-path=""><a href="#最长重复子数组"><i class="fa fa-check"></i><b>1.20</b> 最长重复子数组</a></li>
<li class="chapter" data-level="1.21" data-path=""><a href="#最大正方形"><i class="fa fa-check"></i><b>1.21</b> 最大正方形</a></li>
<li class="chapter" data-level="1.22" data-path=""><a href="#母牛生产一"><i class="fa fa-check"></i><b>1.22</b> 母牛生产一</a></li>
<li class="chapter" data-level="1.23" data-path=""><a href="#母牛生产二"><i class="fa fa-check"></i><b>1.23</b> 母牛生产二</a></li>
<li class="chapter" data-level="1.24" data-path=""><a href="#一和零"><i class="fa fa-check"></i><b>1.24</b> 一和零</a></li>
<li class="chapter" data-level="1.25" data-path=""><a href="#最后一块石头一"><i class="fa fa-check"></i><b>1.25</b> 最后一块石头一</a></li>
<li class="chapter" data-level="1.26" data-path=""><a href="#最后一块石头二"><i class="fa fa-check"></i><b>1.26</b> 最后一块石头二</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">动态规划专题</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="header">
<h1 class="title">动态规划专题</h1>
<p class="author"><em>高文欣</em></p>
<p class="date"><em>2021-08-16</em></p>
</div>
<div id="动态规划问题" class="section level1" number="1">
<h1><span class="header-section-number">1</span> 动态规划问题</h1>
<p>必考题</p>
<p><strong>解题思路</strong>：状态定义，转移方程，初始条件，返回值</p>
<div id="解题思路" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> 解题思路</h2>
<p><a href="https://baijiahao.baidu.com/s?id=1635388976060265522&amp;wfr=spider&amp;for=pc">递归和迭代参考这个解释</a></p>
<p><a href="https://www.zhihu.com/question/23995189">这个讲的太清楚了</a></p>
<p>一言以蔽之：大事化小，小事化了。　　</p>
<p>将一个大问题转化成几个小问题；　　
求解小问题；　　
推出大问题的解。</p>
<p>如何设计DP算法　　
下面介绍比较通用的设计DP算法的步骤。　　
首先，把我们面对的局面表示为x。这一步称为设计状态。　　
对于状态x，记我们要求出的答案(e.g.最小费用)为f(x).我们的目标是求出f(T).找出f(x)与哪些局面有关（记为p），写出一个式子（称为状态转移方程），通过f(p)来推出f(x).<a href="https://www.zhihu.com/question/23995189/answer/613096905">阮行止</a></p>
<p>目前见到的动态规划问题有两种，因此先确定是哪种问题~</p>
<ul>
<li>选择一个解决方案，求<strong>最大/最小的函数值</strong></li>
<li>弄清做某事的<strong>方案，数量</strong>或者事件发生的<strong>概率</strong></li>
</ul>
<p>每个阶段只有一个状态-&gt;递推；</p>
<p>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；</p>
<p>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；</p>
<p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p>
<p><strong><a href="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">判断性继承思想</a></strong></p>
<p>动态规划五部曲</p>
<ul>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ul>
<p>还有一个很重要的，对比递归，大量重复子问题中间结果的保存，dp可以有效的节省存储空间。</p>
<p>动态规划问题树，总结的非常全面</p>
<div class="figure">
<img src="../figs/动态规划问题解题思路.png" alt="" />
<p class="caption">动态规划问题解题思路</p>
</div>
<p>综上其实动态规划大可分为如下几类问题
常见关键词：求。。方法数，集合数，路径数，返回。。长度，最少，最多，最大，最小，最长，最短。。。</p>
<p>-最优方法（路径）数/目标和：青蛙跳台，背包问题，机器人移动路径问题，
- 最优路径和：最大子序和，机器人最小路径和
- 背包问题有一维和二维</p>
<p><strong>解题思路才是最关键的，而不是刷了多少题</strong>
今天看到一个问题，其实大部分问题都可以归为完全背包问题或者0|1背包问题，寻找到子问题是关键。</p>
</div>
<div id="最大子序和问题" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> 最大子序和问题</h2>
<p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释:连续子数组[4,-1,2,1] 的和最大，为6。</p>
<p>dp[i]和dp[i-1]差一个nums[i]</p>
<p>找出状态转移方程：<span class="math inline">\(d p[i]=\max \{n u m s[i], d p[i-1]+n u m s[i]\}\)</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>class Solution<span class="op">:</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="st">    </span>def <span class="kw">maxSubArray</span>(self,nums<span class="op">:</span>List[int])-&gt;int<span class="op">:</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="st">        </span><span class="cf">if</span> <span class="kw">len</span>(nums)<span class="op">==</span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>        <span class="cf">if</span> <span class="kw">len</span>(nums)<span class="op">==</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="st">            </span>range nums[<span class="dv">0</span>]</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>        res=nums[<span class="dv">0</span>]</span>
<span id="cb1-9"><a href="#cb1-9"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,<span class="kw">len</span>(nums))<span class="op">:</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="st">            </span>nums[i]=<span class="kw">max</span>(nums[i],nums[i]<span class="op">+</span>nums[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a>            res=<span class="kw">max</span>(res,num[i])</span>
<span id="cb1-13"><a href="#cb1-13"></a>        return res</span></code></pre></div>
<p>这一种写法比较直观</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a></span>
<span id="cb2-2"><a href="#cb2-2"></a>from typing import List</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>class Solution<span class="op">:</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="st">    </span>def <span class="kw">maxSubArray</span>(self, nums<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="st">        </span>size =<span class="st"> </span><span class="kw">len</span>(nums)</span>
<span id="cb2-8"><a href="#cb2-8"></a>        <span class="cf">if</span> size <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>        dp =<span class="st"> </span>[<span class="dv">0</span> <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(size)]</span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a>        dp[<span class="dv">0</span>] =<span class="st"> </span>nums[<span class="dv">0</span>]</span>
<span id="cb2-13"><a href="#cb2-13"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, size)<span class="op">:</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="st">            </span>dp[i] =<span class="st"> </span><span class="kw">max</span>(dp[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>nums[i], nums[i])</span>
<span id="cb2-15"><a href="#cb2-15"></a>        return <span class="kw">max</span>(dp)</span>
<span id="cb2-16"><a href="#cb2-16"></a></span>
<span id="cb2-17"><a href="#cb2-17"></a></span></code></pre></div>
</div>
<div id="最长上升子序列" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> 最长上升子序列</h2>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<p>输入: [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
<strong>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</strong></p>
<p>解题思路：枚举</p>
<p>给个时间复杂度为<span class="math inline">\(O(n^2)\)</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>class Solution<span class="op">:</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="st">    </span>def <span class="kw">lengthOfLIS</span>(self, nums<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="st">        </span><span class="cf">if</span> nums<span class="op">==</span>[]<span class="op">:</span><span class="st"> </span>return <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>        length=<span class="kw">len</span>(nums)</span>
<span id="cb3-5"><a href="#cb3-5"></a>        <span class="co"># 暂存子序列长度，1 个字符显然是长度为 1 的上升子序列</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>        dp=[<span class="dv">1</span> <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(length)]</span>
<span id="cb3-7"><a href="#cb3-7"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(length)<span class="op">:</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">0</span>,i)<span class="op">:</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="st">                </span><span class="cf">if</span> nums[i]<span class="op">&gt;</span>nums[j]<span class="op">:</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="st">                    </span><span class="co"># 状态：dp[i] 表示以 nums[i] 结尾的「上升子序列」的长度</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="st">                    </span><span class="co"># 当nums[i]前面存在小于nums[i]的nums[j],</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="st">                    </span><span class="co"># 则暂存在dp[j]+1就是当前nums[i]的最长增长子序列的长度</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="st">                    </span>dp[i]=<span class="kw">max</span>(dp[i],dp[j]<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb3-14"><a href="#cb3-14"></a>        return <span class="kw">max</span>(dp)</span></code></pre></div>
</div>
<div id="最短路径和问题" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> 最短路径和问题</h2>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<p>输入:
[
  [1,3,1],
[1,5,1],
[4,2,1]]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<p><img src="../figs/最短路径和的问题.png" alt="最短路径和的问题" />
二维的动态规划</p>
<p>i横向,j纵向</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>class Solution<span class="op">:</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="st">    </span>def <span class="kw">minPathSum</span>(self, grid<span class="op">:</span><span class="st"> </span>[[int]]) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="st">        </span><span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(grid))<span class="op">:</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(grid[<span class="dv">0</span>]))<span class="op">:</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="st">                </span><span class="cf">if</span> i <span class="op">==</span><span class="st"> </span>j <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="st"> </span>continue</span>
<span id="cb4-6"><a href="#cb4-6"></a>                elif i <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="st">  </span>grid[i][j] =<span class="st"> </span>grid[i][j <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>grid[i][j]</span>
<span id="cb4-7"><a href="#cb4-7"></a>                elif j <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="st">  </span>grid[i][j] =<span class="st"> </span>grid[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>][j] <span class="op">+</span><span class="st"> </span>grid[i][j]</span>
<span id="cb4-8"><a href="#cb4-8"></a>                <span class="cf">else</span><span class="op">:</span><span class="st"> </span>grid[i][j] =<span class="st"> </span><span class="kw">min</span>(grid[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>][j], grid[i][j <span class="op">-</span><span class="st"> </span><span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span>grid[i][j]</span>
<span id="cb4-9"><a href="#cb4-9"></a>        return grid[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
</div>
<div id="爬楼梯问题" class="section level2" number="1.5">
<h2><span class="header-section-number">1.5</span> 爬楼梯问题</h2>
<p>斐波那契数列：只需要考虑最后到达最后一阶实现的几种情况</p>
<p>题目一般有2种，可以爬2阶或者3阶，思路一样，递归+DP，但是要注意时间复杂度。。</p>
<p>或者爬1阶，2阶</p>
<p>假设你正在爬楼梯。需要 n阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<p>输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：</p>
<p>输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>class Solution<span class="op">:</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="st">    </span>def <span class="kw">climbStairs</span>(self, n<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="st">        </span>res =<span class="st"> </span>[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span><span class="dv">46</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>        res[<span class="dv">0</span>] =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>        res[<span class="dv">1</span>] =<span class="st"> </span><span class="dv">2</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>        </span>
<span id="cb5-7"><a href="#cb5-7"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">2</span>,n)<span class="op">:</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="st">            </span>res[i] =<span class="st"> </span>res[i<span class="dv">-1</span>] <span class="op">+</span><span class="st"> </span>res[i<span class="dv">-2</span>]</span>
<span id="cb5-9"><a href="#cb5-9"></a>        return res[n<span class="dv">-1</span>]</span></code></pre></div>
<p>画个图发现就是二叉树的遍历</p>
</div>
<div id="不同路径" class="section level2" number="1.6">
<h2><span class="header-section-number">1.6</span> 不同路径</h2>
<p><img src="../figs/不同路径.png" />
解题思路:与爬楼梯的思路一致</p>
<p>令 dp[i][j] 是到达 i, j 最多路径</p>
<p>状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]</p>
<p><strong>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</strong></p>
<p>时间复杂度：O(m*n)</p>
<p>空间复杂度：O(m∗n)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>class Solution<span class="op">:</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="st">    </span>def <span class="kw">uniquePaths</span>(self, m<span class="op">:</span><span class="st"> </span>int, n<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="st">        </span>d =<span class="st"> </span>[[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(m)]</span>
<span id="cb6-4"><a href="#cb6-4"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(m)<span class="op">:</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="st">            </span>d[i][<span class="dv">0</span>] =<span class="st"> </span><span class="dv">1</span> <span class="co"># 从（0,0）出发，边界上的点只能一直向右走或者向下走，所以到边界上的点只有一种走法</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>        <span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="st">            </span>d[<span class="dv">0</span>][j] =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,m)<span class="op">:</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,n)<span class="op">:</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="st">                </span>d[i][j] =<span class="st"> </span>d[i<span class="dv">-1</span>][j]<span class="op">+</span>d[i][j<span class="dv">-1</span>]</span>
<span id="cb6-11"><a href="#cb6-11"></a>        return d[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb6-12"><a href="#cb6-12"></a>        </span></code></pre></div>
<p><strong>优化</strong>：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p>
<p>因此可以考虑降空间复杂度，减少一个数组</p>
<blockquote>
<p>当前点为上面点加左边点，那么计算第二行时可以直接在第一行计算，及当前点加左边点就ok了，当前点原来值表示上一行的上面点的值。所以实际一行数组重复计算就完事了。</p>
</blockquote>
<p>这个思路太强了，不好想~</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>class Solution<span class="op">:</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="st">    </span>def <span class="kw">uniquePaths</span>(self, m<span class="op">:</span><span class="st"> </span>int, n<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="st">        </span>cur =<span class="st"> </span>[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>n </span>
<span id="cb7-4"><a href="#cb7-4"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, m)<span class="op">:</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, n)<span class="op">:</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="st">                </span>cur[j] <span class="op">+</span><span class="er">=</span><span class="st"> </span>cur[j<span class="dv">-1</span>] <span class="co">#等号右边分别是该位置上边的值和左边的值</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>        return cur[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb7-8"><a href="#cb7-8"></a></span></code></pre></div>
</div>
<div id="最长回文字符串" class="section level2" number="1.7">
<h2><span class="header-section-number">1.7</span> 最长回文字符串</h2>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<p>输入: “babad”
输出: “bab”
注意: “aba” 也是一个有效答案。
示例 2：</p>
<p>输入: “cbbd”
输出: “bb”</p>
<ul>
<li>动态规划法</li>
</ul>
<p>学习weiwei思路，很快就理解了，这里写下我的总结</p>
<p>动态规划：填dp表、当前ij状态、过去ij状态、如何联合得到输出、边界条件</p>
<p>定义状态：题目让我们求什么，就把什么设置为状态
题目求s中最长的回文子串，那就判断所有子串是否为回文子串，选出最长的
因此：dp[i][j]表示s[i:j+1]是否为回文子串（这里+1是为了构造闭区间）</p>
<p>状态转移方程：对空间进行分类讨论（当前ij状态、过去ij状态 如何联合得到输出）
当前ij状态：头尾必须相等（s[i]==s[j]）
过去ij状态：去掉头尾之后还是一个回文（dp[i+1][j-1] is True）
边界条件：只要是找过去ij状态的时候，就会涉及边界条件（即超出边界情况处理）
当i==j时一定是回文
j-1-(i+1)&lt;=0,即j-i&lt;=2时，只要当s[i]==s[j]时就是回文，不用判断dp[i+1][j-1]
dp[i][j] 为截取的子串</p>
<p>初始状态：这里已经直接判断j-i&lt;=2的情况了，因此用不到初始状态，可以不设</p>
<p>输出内容：每次发现新回文都比较一下长度，记录i与长度</p>
<p>优化空间提速</p>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-dong-tai-gu-p7uk/">：_Breiman</a></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a></span>
<span id="cb8-2"><a href="#cb8-2"></a>class Solution<span class="op">:</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="st">    </span>def <span class="kw">longestPalindrome</span>(self, s<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>str<span class="op">:</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="st">        </span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="st">        </span>size =<span class="st"> </span><span class="kw">len</span>(s)</span>
<span id="cb8-6"><a href="#cb8-6"></a>        <span class="co"># 特殊处理</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>        <span class="cf">if</span> size <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="st">            </span>return s</span>
<span id="cb8-9"><a href="#cb8-9"></a>        <span class="co"># 创建动态规划dynamic programing表</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>        dp =<span class="st"> </span>[[False <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(size)] <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(size)]</span>
<span id="cb8-11"><a href="#cb8-11"></a>        <span class="co"># 初始长度为1，这样万一不存在回文，就返回第一个值（初始条件设置的时候一定要考虑输出）</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>        max_len =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>        start =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>        <span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,size)<span class="op">:</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="st">            </span><span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(j)<span class="op">:</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="st">                </span><span class="co"># 边界条件：</span></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="st">                </span><span class="co"># 只要头尾相等（s[i]==s[j]）就能返回True</span></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="st">                </span><span class="cf">if</span> j<span class="op">-</span>i<span class="op">&lt;=</span><span class="dv">2</span><span class="op">:</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="st">                    </span><span class="cf">if</span> s[i]<span class="op">==</span>s[j]<span class="op">:</span></span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="st">                        </span>dp[i][j] =<span class="st"> </span>True</span>
<span id="cb8-21"><a href="#cb8-21"></a>                        cur_len =<span class="st"> </span>j<span class="op">-</span>i<span class="op">+</span><span class="dv">1</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>                <span class="co"># 状态转移方程 </span></span>
<span id="cb8-23"><a href="#cb8-23"></a>                <span class="co"># 当前dp[i][j]状态：头尾相等（s[i]==s[j]）</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>                <span class="co"># 过去dp[i][j]状态：去掉头尾之后还是一个回文（dp[i+1][j-1] is True）</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>                <span class="cf">else</span><span class="op">:</span></span>
<span id="cb8-26"><a href="#cb8-26"></a><span class="st">                    </span><span class="cf">if</span> s[i]<span class="op">==</span>s[j] and dp[i<span class="op">+</span><span class="dv">1</span>][j<span class="dv">-1</span>]<span class="op">:</span></span>
<span id="cb8-27"><a href="#cb8-27"></a><span class="st">                        </span>dp[i][j] =<span class="st"> </span>True</span>
<span id="cb8-28"><a href="#cb8-28"></a>                        cur_len =<span class="st"> </span>j<span class="op">-</span>i<span class="op">+</span><span class="dv">1</span></span>
<span id="cb8-29"><a href="#cb8-29"></a>                <span class="co"># 出现回文更新输出</span></span>
<span id="cb8-30"><a href="#cb8-30"></a>                <span class="cf">if</span> dp[i][j]<span class="op">:</span></span>
<span id="cb8-31"><a href="#cb8-31"></a><span class="st">                    </span><span class="cf">if</span> cur_len <span class="op">&gt;</span><span class="st"> </span>max_len<span class="op">:</span></span>
<span id="cb8-32"><a href="#cb8-32"></a><span class="st">                        </span>max_len =<span class="st"> </span>cur_len</span>
<span id="cb8-33"><a href="#cb8-33"></a>                        start =<span class="st"> </span>i</span>
<span id="cb8-34"><a href="#cb8-34"></a></span>
<span id="cb8-35"><a href="#cb8-35"></a>        return s[start<span class="op">:</span>start<span class="op">+</span>max_len]</span>
<span id="cb8-36"><a href="#cb8-36"></a></span></code></pre></div>
<ul>
<li>双指真法</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>class Solution<span class="op">:</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="st">    </span>def <span class="kw">longestPalindrome</span>(self, s<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>str<span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="st">        </span>n =<span class="st"> </span><span class="kw">len</span>(s)</span>
<span id="cb9-4"><a href="#cb9-4"></a>        dp =<span class="st"> </span>[[False] <span class="op">*</span><span class="st"> </span>n <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(n)]</span>
<span id="cb9-5"><a href="#cb9-5"></a>        ans =<span class="st"> &quot;&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>        <span class="co"># 枚举子串的长度 l+1</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>        <span class="cf">for</span> l <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="st">            </span><span class="co"># 枚举子串的起始位置 i，这样可以通过 j=i+l 得到子串的结束位置</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="st">            </span><span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="st">                </span>j =<span class="st"> </span>i <span class="op">+</span><span class="st"> </span>l</span>
<span id="cb9-11"><a href="#cb9-11"></a>                <span class="cf">if</span> j <span class="op">&gt;=</span><span class="st"> </span><span class="kw">len</span>(s)<span class="op">:</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="st">                    </span><span class="cf">break</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>                <span class="cf">if</span> l <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="st">                    </span>dp[i][j] =<span class="st"> </span>True</span>
<span id="cb9-15"><a href="#cb9-15"></a>                elif l <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="st">                    </span>dp[i][j] =<span class="st"> </span>(s[i] <span class="op">==</span><span class="st"> </span>s[j])</span>
<span id="cb9-17"><a href="#cb9-17"></a>                <span class="cf">else</span><span class="op">:</span></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="st">                    </span>dp[i][j] =<span class="st"> </span>(dp[i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>][j <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] and s[i] <span class="op">==</span><span class="st"> </span>s[j])</span>
<span id="cb9-19"><a href="#cb9-19"></a>                <span class="cf">if</span> dp[i][j] and l <span class="op">+</span><span class="st"> </span><span class="dv">1</span> <span class="op">&gt;</span><span class="st"> </span><span class="kw">len</span>(ans)<span class="op">:</span></span>
<span id="cb9-20"><a href="#cb9-20"></a><span class="st">                    </span>ans =<span class="st"> </span>s[i<span class="op">:</span>j<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb9-21"><a href="#cb9-21"></a>        return ans</span>
<span id="cb9-22"><a href="#cb9-22"></a></span></code></pre></div>
</div>
<div id="回文子字符串数量" class="section level2" number="1.8">
<h2><span class="header-section-number">1.8</span> 回文子字符串数量</h2>
<p>题目链接：<a href="https://leetcode-cn.com/problems/palindromic-substrings/" class="uri">https://leetcode-cn.com/problems/palindromic-substrings/</a></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<p>输入：“abc” 输出：3 解释：三个回文子串: “a”, “b”, “c”</p>
<p>示例 2：</p>
<p>输入：“aaa” 输出：6 解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>
<p>提示：</p>
<p>输入的字符串长度不会超过 1000 。</p>
<p>动规五部曲：</p>
<p>1.确定dp数组（dp table）以及下标的含义
布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</p>
<p>2.确定递推公式
在确定递推公式时，就要分析如下几种情况。</p>
<p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<p>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
情况二：下标i 与 j相差为1，例如aa，也是回文子串
情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>class Solution<span class="op">:</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="st">    </span>def <span class="kw">countSubstrings</span>(self, s<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="st">        </span>dp =<span class="st"> </span>[[False] <span class="op">*</span><span class="st"> </span><span class="kw">len</span>(s) <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(s))]</span>
<span id="cb10-4"><a href="#cb10-4"></a>        result =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(s)<span class="op">-</span><span class="dv">1</span>, <span class="dv">-1</span>, <span class="dv">-1</span>)<span class="op">:</span><span class="st"> </span><span class="co">#注意遍历顺序，这个真的额是重点</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(i, <span class="kw">len</span>(s))<span class="op">:</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="st">                </span><span class="cf">if</span> s[i] <span class="op">==</span><span class="st"> </span>s[j]<span class="op">:</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="st">                    </span><span class="cf">if</span> j <span class="op">-</span><span class="st"> </span>i <span class="op">&lt;=</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="co">#情况一 和 情况二</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="st">                        </span>result <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>                        dp[i][j] =<span class="st"> </span>True</span>
<span id="cb10-11"><a href="#cb10-11"></a>                    elif dp[i<span class="op">+</span><span class="dv">1</span>][j<span class="dv">-1</span>]<span class="op">:</span><span class="st"> </span><span class="co">#情况三</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="st">                        </span>result <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>                        dp[i][j] =<span class="st"> </span>True</span>
<span id="cb10-14"><a href="#cb10-14"></a>        return result</span></code></pre></div>
</div>
<div id="最大乘积和" class="section level2" number="1.9">
<h2><span class="header-section-number">1.9</span> 最大乘积和</h2>
<p>这个题一开始我想的很简单，就类似与最大上升子序和来做了，结果。。。==</p>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:</p>
<p>输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<p>解题思路</p>
<p>首先假设存在某个最大乘积，然后对数组遍历，在经过每个元素的时候，有以下四种情况：</p>
<p><strong>如果该元素为正数：</strong></p>
<ul>
<li>如果到上一个元素为止的最大乘积也是正数，那么直接乘上就好了，同样的最大乘积也会变得更大</li>
<li>如果到上一个元素为止的最大乘积是负数，那么最大乘积就会变成该元素本身，且连续性被断掉</li>
</ul>
<p><strong>如果该元素为负数：</strong></p>
<ul>
<li>如果到上一个元素为止的最大乘积也是负数，那么直接乘上就好了，同样的最大乘积也会变得更大</li>
<li>如果到上一个元素为止的最大乘积是正数，那么最大乘积就会不变，且连续性被断掉</li>
</ul>
<p>以上四种情况中说到的最大乘积都是临时最大乘积，每遍历新的元素都需要进行比较来确定真正的最大乘积。</p>
<p><strong>如果细心的话就可以发现，如果要得到乘以当前元素以后的最大乘积，需要记录最大乘积，也要记录最小乘积，因为最小值可能翻身变最大值。</strong></p>
<p>对对对对。。。需要用两个记录两个值。。</p>
<p>负负为正
负正为负</p>
<p>但是看成是动态规划问题挺不好想的，只能多看几遍了</p>
<p>时间复杂度是O(n)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>class Solution<span class="op">:</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="st">    </span>def <span class="kw">maxProduct</span>(self, nums<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="st">        </span><span class="cf">if</span> not nums<span class="op">:</span><span class="st"> </span>return </span>
<span id="cb11-4"><a href="#cb11-4"></a>        res =<span class="st"> </span>nums[<span class="dv">0</span>]</span>
<span id="cb11-5"><a href="#cb11-5"></a>        pre_max =<span class="st"> </span>nums[<span class="dv">0</span>]</span>
<span id="cb11-6"><a href="#cb11-6"></a>        pre_min =<span class="st"> </span>nums[<span class="dv">0</span>]</span>
<span id="cb11-7"><a href="#cb11-7"></a>        <span class="cf">for</span> num <span class="cf">in</span> nums[<span class="dv">1</span><span class="op">:</span>]<span class="op">:</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="st">            </span>cur_max =<span class="st"> </span><span class="kw">max</span>(pre_max <span class="op">*</span><span class="st"> </span>num, pre_min <span class="op">*</span><span class="st"> </span>num, num)<span class="co">#pre_max:之前的最大值</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>            cur_min =<span class="st"> </span><span class="kw">min</span>(pre_max <span class="op">*</span><span class="st"> </span>num, pre_min <span class="op">*</span><span class="st"> </span>num, num)<span class="co">#pre_min:之前的最小值，num:当前值</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>            res =<span class="st"> </span><span class="kw">max</span>(res, cur_max)</span>
<span id="cb11-11"><a href="#cb11-11"></a>            pre_max =<span class="st"> </span>cur_max</span>
<span id="cb11-12"><a href="#cb11-12"></a>            pre_min =<span class="st"> </span>cur_min</span>
<span id="cb11-13"><a href="#cb11-13"></a>        return res</span></code></pre></div>
</div>
<div id="买卖股票专题" class="section level2" number="1.10">
<h2><span class="header-section-number">1.10</span> 买卖股票专题</h2>
<p><strong>买卖股票的最佳时机 I</strong></p>
<p>交易限制在一次了</p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:</p>
<p>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p><strong>分析：</strong>第一题，相对简单，只能有一次交易。刚看到第一反应可能是遍历两次，找出所有的利润，选个最大的，意料之中，复杂度O（n^2）肯定超时。<strong>在一次遍历中，可以记录最小值，同时记录对应的利润即可。</strong></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>class Solution<span class="op">:</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="st">    </span>def <span class="kw">maxProfit</span>(self, prices)<span class="op">:</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="st">        :type prices: List[int]</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="st">        :rtype: int</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>        <span class="cf">if</span> <span class="kw">len</span>(prices)<span class="op">&lt;</span><span class="dv">2</span><span class="op">:</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>        profit =<span class="st"> </span><span class="dv">0</span> <span class="co">#最初的利润是0</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>        minprice =<span class="st"> </span>prices[<span class="dv">0</span>]</span>
<span id="cb12-11"><a href="#cb12-11"></a>        <span class="cf">for</span> i <span class="cf">in</span> prices<span class="op">:</span></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="st">            </span>minprice =<span class="st"> </span><span class="kw">min</span>(i,minprice)</span>
<span id="cb12-13"><a href="#cb12-13"></a>            profit =<span class="st"> </span><span class="kw">max</span>(i<span class="op">-</span>minprice,profit) <span class="co">#找到最小的价格和最大的价格做差，与当前利润进行比较</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>        return profit</span></code></pre></div>
<p>动态规划实现</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>class Solution<span class="op">:</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="st">    </span>def <span class="kw">maxProfit</span>(self, prices<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="st">        </span>n =<span class="st"> </span><span class="kw">len</span>(prices)</span>
<span id="cb13-4"><a href="#cb13-4"></a>        <span class="cf">if</span> not n or n <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span><span class="op">:</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>        dp =<span class="st"> </span>[[<span class="dv">0</span>,<span class="dv">0</span>] <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n)]</span>
<span id="cb13-7"><a href="#cb13-7"></a>        dp[<span class="dv">0</span>][<span class="dv">0</span>] =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>        dp[<span class="dv">0</span>][<span class="dv">1</span>] =<span class="st"> </span><span class="op">-</span>prices[<span class="dv">0</span>]</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,n)<span class="op">:</span></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="st">            </span>dp[i][<span class="dv">0</span>] =<span class="st"> </span><span class="kw">max</span>(dp[i<span class="dv">-1</span>][<span class="dv">0</span>],dp[i<span class="dv">-1</span>][<span class="dv">1</span>]<span class="op">+</span>prices[i])</span>
<span id="cb13-12"><a href="#cb13-12"></a>            dp[i][<span class="dv">1</span>] =<span class="st"> </span><span class="kw">max</span>(dp[i<span class="dv">-1</span>][<span class="dv">1</span>],<span class="op">-</span>prices[i])</span>
<span id="cb13-13"><a href="#cb13-13"></a>        return dp[n<span class="dv">-1</span>][<span class="dv">0</span>]</span></code></pre></div>
<p><strong>买卖股票的最佳时机 II</strong></p>
<p>无限次交易</p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
  随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:</p>
<p>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
  注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
  因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:</p>
<p>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>分析：<strong>不限制交易次数，其实看起来比还要简单，可以直接一次遍历，把后一项大于前一项时，两者差值相加即可。</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>class Solution<span class="op">:</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="st">    </span>def <span class="kw">maxProfit</span>(self, prices)<span class="op">:</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="st">        :type prices: List[int]</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="st">        :rtype: int</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>        <span class="cf">if</span> not prices<span class="op">:</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>        temp =<span class="st"> </span>prices[<span class="dv">0</span>]</span>
<span id="cb14-10"><a href="#cb14-10"></a>        profit =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>        <span class="cf">for</span> i <span class="cf">in</span> prices<span class="op">:</span></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="st">            </span><span class="cf">if</span> i <span class="op">&gt;</span><span class="st"> </span>temp<span class="op">:</span></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="st">                </span>profit =<span class="st"> </span>profit <span class="op">+</span><span class="st"> </span>i <span class="op">-</span><span class="st"> </span>temp</span>
<span id="cb14-14"><a href="#cb14-14"></a>            temp =<span class="st"> </span>i</span>
<span id="cb14-15"><a href="#cb14-15"></a>        return profit</span></code></pre></div>
<p><strong>买卖股票的最佳时机 III</strong></p>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
  随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2:</p>
<p>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。  
  注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。  
  因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:</p>
<p>输入: [7,6,4,3,1]
输出: 0
解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</p>
<p><strong>分析</strong>：此题加深了难度，限制了建议次数不大于2。最开始的想法是二分，遍历所有值作为二分点，分成左右两部分，分别求利润再求和，最后取最大，时间复杂度O(N^2)，结果在倒数第二个评测时超时。优化一下，可以先从前往后遍历，按照 I中的思路，将遍历到的每个值对应的最大利润存在一个列表中，然后从后往前遍历，在求此时的最大利润时，同时加上数组中的对应值，再取最大，即为所求。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>class Solution<span class="op">:</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="st">    </span>def <span class="kw">maxProfit</span>(self, prices)<span class="op">:</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="st">        :type prices: List[int]</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="st">        :rtype: int</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>        <span class="cf">if</span> <span class="kw">len</span>(prices)<span class="op">&lt;</span><span class="dv">2</span><span class="op">:</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>        minprice =<span class="st"> </span>prices[<span class="dv">0</span>]</span>
<span id="cb15-10"><a href="#cb15-10"></a>        maxprice =<span class="st"> </span>prices[<span class="kw">len</span>(prices)<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb15-11"><a href="#cb15-11"></a>        profit1 =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>        profit2 =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb15-13"><a href="#cb15-13"></a>        profit =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>        a =<span class="st"> </span>[]</span>
<span id="cb15-15"><a href="#cb15-15"></a>        <span class="cf">for</span> m <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">0</span>,<span class="kw">len</span>(prices))<span class="op">:</span></span>
<span id="cb15-16"><a href="#cb15-16"></a><span class="st">            </span>profit1 =<span class="st"> </span><span class="kw">max</span>(profit1,prices[m]<span class="op">-</span>minprice)</span>
<span id="cb15-17"><a href="#cb15-17"></a>            minprice =<span class="st"> </span><span class="kw">min</span>(prices[m],minprice)</span>
<span id="cb15-18"><a href="#cb15-18"></a>            <span class="kw">a.append</span>(profit1)</span>
<span id="cb15-19"><a href="#cb15-19"></a>        <span class="cf">for</span> n <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(prices)<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb15-20"><a href="#cb15-20"></a><span class="st">            </span>maxprice =<span class="st"> </span><span class="kw">max</span>(prices[n],maxprice)</span>
<span id="cb15-21"><a href="#cb15-21"></a>            profit2 =<span class="st"> </span><span class="kw">max</span>(profit2,maxprice<span class="op">-</span>prices[n])</span>
<span id="cb15-22"><a href="#cb15-22"></a>            profit =<span class="st"> </span><span class="kw">max</span>(profit,a[n]<span class="op">+</span>profit2)</span>
<span id="cb15-23"><a href="#cb15-23"></a>        return profit</span></code></pre></div>
</div>
<div id="完全平方数" class="section level2" number="1.11">
<h2><span class="header-section-number">1.11</span> 完全平方数</h2>
<p>这题没想起来怎么转，知道想起找零钱的那个题。</p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<p>输入: n = 12
输出: 3
解释: 12 = 4 + 4 + 4.
示例 2:</p>
<p>输入: n = 13
输出: 2
解释: 13 = 4 + 9.</p>
<p>感觉有点像coin那个题</p>
<p>dp[i]表示i最少可以由几个平方数构成。</p>
<p>初试化<span class="math inline">\(dp=[0,1,2,⋯,n]\)</span>，长度为n+1，最多次数就是全由1构成。</p>
<p>遍历dp，对于i，遍历区间[2,n+1)：</p>
<p>遍历所有平方数小于i的数j，遍历区间<span class="math inline">\([1,int(\sqrt{i})+1)\)</span>：
<span class="math inline">\(dp[i]=min(dp[i],dp[i-j*j]+1)\)</span>。始终保存所有可能情况中的最小值。
返回dp[n]</p>
<p>因此时间复杂度是：O(n)
空间复杂度：O(n)</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>class Solution<span class="op">:</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="st">    </span>def <span class="kw">numSquares</span>(self, n<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="st">        </span>dp=[i <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb16-4"><a href="#cb16-4"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">2</span>,n<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,<span class="kw">int</span>(i<span class="op">**</span>(<span class="fl">0.5</span>))<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="st">                </span>dp[i]=<span class="kw">min</span>(dp[i],dp[i<span class="op">-</span>j<span class="op">*</span>j]<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb16-7"><a href="#cb16-7"></a>        return dp[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
</div>
<div id="找零钱问题" class="section level2" number="1.12">
<h2><span class="header-section-number">1.12</span> 找零钱问题</h2>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: coins = [1, 2, 5], amount = 11
输出: 3
解释: 11 = 5 + 5 + 1
示例 2:</p>
<p>输入: coins = [2], amount = 3
输出: -1</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>class Solution<span class="op">:</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="st">    </span>def <span class="kw">coinChange</span>(self, coins<span class="op">:</span><span class="st"> </span>List[int], amount<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="st">        </span>dp=[<span class="kw">float</span>(<span class="st">&#39;inf&#39;</span>)]<span class="op">*</span>(amount<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb17-4"><a href="#cb17-4"></a>        dp[<span class="dv">0</span>]=<span class="dv">0</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,amount<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="st">            </span><span class="cf">for</span> coin <span class="cf">in</span> coins<span class="op">:</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="st">                </span><span class="cf">if</span> i<span class="op">&gt;=</span>coin<span class="op">:</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="st">                    </span>dp[i]=<span class="kw">min</span>(dp[i],dp[i<span class="op">-</span>coin]<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb17-9"><a href="#cb17-9"></a>        return dp[<span class="op">-</span><span class="dv">1</span>] <span class="cf">if</span>(dp[<span class="op">-</span><span class="dv">1</span>]<span class="op">!=</span><span class="kw">float</span>(<span class="st">&#39;inf&#39;</span>)) <span class="cf">else</span> <span class="dv">-1</span></span></code></pre></div>
<p>目前的时间复杂度O(amount*len(coins))</p>
<p>有么有更快的方法？
有的，回溯算法+dbf</p>
<p>可以查查，理解下~</p>
<p>找零钱问题是背包问题的一个例子</p>
</div>
<div id="单词切分" class="section level2" number="1.13">
<h2><span class="header-section-number">1.13</span> 单词切分</h2>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：</p>
<p>输入: s = “leetcode”, wordDict = [“leet”, “code”]
输出: true
解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。
示例 2：</p>
<p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]
输出: true
解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。
  注意你可以重复使用字典中的单词。
示例 3：</p>
<p>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]
输出: false</p>
<p><strong>解题思路</strong></p>
<ol style="list-style-type: decimal">
<li>初始化 <span class="math inline">\(d p=[\text { False, } \cdots, \text { False], 长度为 } n+1 . n \text { 为字符串长度。 } d p[i] \text { 表示 } s \text { 的前 } i\)</span> 位是否可以用 wordDict 中的单词表示。</li>
<li>初始化 <span class="math inline">\(d p[0]=T r u e,\)</span> 空字符可以被表示</li>
<li>遍历字符串的所有子串，遍历开始索引 <span class="math inline">\(i,\)</span> 遍历区间 <span class="math inline">\([0, n)\)</span>
。遍历结束索引 <span class="math inline">\(j,\)</span> 遍历区间 <span class="math inline">\([i+1, n+1)\)</span></li>
</ol>
<ul>
<li>若 <span class="math inline">\(d p[i]=\)</span> True 且 <span class="math inline">\(s[i, \cdots, j)\)</span> 在 wordlist 中: <span class="math inline">\(d p[j]=T r u e_{\circ}\)</span> 解释: <span class="math inline">\(d p[i]=\)</span> True i兄明 <span class="math inline">\(s\)</span> 的前 <span class="math inline">\(i\)</span> 位可以用 <span class="math inline">\(w o r d D i c t\)</span> 表示, 则 <span class="math inline">\(s[i, \cdots, j)\)</span> 出现在 <span class="math inline">\(w o r d D i c t\)</span> 中，说明 <span class="math inline">\(s\)</span> 的前 <span class="math inline">\(j\)</span> 位可以 表示。</li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>返回 <span class="math inline">\(d p[n]\)</span></li>
</ol>
<p>问题不难，就是没想到用动态规划</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>class Solution<span class="op">:</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="st">    </span>def <span class="kw">wordBreak</span>(self, s<span class="op">:</span><span class="st"> </span>str, wordDict<span class="op">:</span><span class="st"> </span>List[str]) -&gt;<span class="st"> </span>bool<span class="op">:</span><span class="st">       </span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="st">        </span>n=<span class="kw">len</span>(s)</span>
<span id="cb18-4"><a href="#cb18-4"></a>        dp=[False]<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb18-5"><a href="#cb18-5"></a>        dp[<span class="dv">0</span>]=True</span>
<span id="cb18-6"><a href="#cb18-6"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(i<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="st">                </span><span class="cf">if</span>(dp[i] <span class="kw">and</span> (s[i<span class="op">:</span>j] <span class="cf">in</span> wordDict))<span class="op">:</span></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="st">                    </span>dp[j]=True</span>
<span id="cb18-10"><a href="#cb18-10"></a>        return dp[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
</div>
<div id="打家劫舍专题" class="section level2" number="1.14">
<h2><span class="header-section-number">1.14</span> 打家劫舍专题</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
  偷窃到的最高金额 = 1 + 3 = 4 。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>class Solution<span class="op">:</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="st">    </span>def <span class="kw">rob</span>(self, nums<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="st">       </span>prev =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>       curr =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>    </span>
<span id="cb19-6"><a href="#cb19-6"></a>     <span class="co"># 每次循环，计算“偷到当前房子为止的最大金额”</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>       <span class="cf">for</span> i <span class="cf">in</span> nums<span class="op">:</span></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="st">        </span><span class="co"># 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="st">        </span><span class="co"># dp[k] = max{ dp[k-1], dp[k-2] + i }</span></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="st">           </span>prev, curr =<span class="st"> </span>curr, <span class="kw">max</span>(curr, prev <span class="op">+</span><span class="st"> </span>i)</span>
<span id="cb19-11"><a href="#cb19-11"></a>        <span class="co"># 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]</span></span>
<span id="cb19-12"><a href="#cb19-12"></a></span>
<span id="cb19-13"><a href="#cb19-13"></a>       return curr</span></code></pre></div>
<p>或者另一种写法,即动态规划，</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a></span>
<span id="cb20-2"><a href="#cb20-2"></a>class Solution<span class="op">:</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="st">    </span>def <span class="kw">rob</span>(self, nums)<span class="op">:</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="st">        </span><span class="cf">if</span> not nums<span class="op">:</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>        <span class="cf">if</span> <span class="kw">len</span>(nums)<span class="op">==</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="st">            </span>return nums[<span class="dv">0</span>]</span>
<span id="cb20-8"><a href="#cb20-8"></a>        sumList =<span class="st"> </span>[nums[<span class="dv">0</span>]]      <span class="co">#存放盗窃的每一个房间的最大收益</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>        <span class="kw">sumList.append</span>(<span class="kw">max</span>(nums[<span class="dv">0</span>], nums[<span class="dv">1</span>]))</span>
<span id="cb20-10"><a href="#cb20-10"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">2</span>,<span class="kw">len</span>(nums))<span class="op">:</span></span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="st">            </span><span class="kw">sumList.append</span>(<span class="kw">max</span>(sumList[i<span class="dv">-2</span>]<span class="op">+</span>nums[i], sumList[i<span class="dv">-1</span>]))</span>
<span id="cb20-12"><a href="#cb20-12"></a>        return sumList[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<p>问题2：环形房屋</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2:</p>
<p>输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
  偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>解题思路：可以开辟2个队列保存结果嘛,第一个队列保存从[0,n-1]的结果，第二个队列保存从[1,n]的结果</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="st">    </span>def <span class="kw">rob</span>(self, nums)<span class="op">:</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="st">        </span><span class="cf">if</span> not nums<span class="op">:</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>        n =<span class="st"> </span><span class="kw">len</span>(nums)</span>
<span id="cb21-6"><a href="#cb21-6"></a>        <span class="cf">if</span> n<span class="op">&lt;=</span><span class="dv">2</span><span class="op">:</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="st">            </span>return <span class="kw">max</span>(nums)</span>
<span id="cb21-8"><a href="#cb21-8"></a>        dp1 =<span class="st"> </span>[<span class="dv">0</span> <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(n)]</span>
<span id="cb21-9"><a href="#cb21-9"></a>        dp2 =<span class="st"> </span>[<span class="dv">0</span> <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(n)]</span>
<span id="cb21-10"><a href="#cb21-10"></a>        <span class="co"># 初始化两个dp数组，dp1是计算的是[1,end],dp2计算的是[0,end-1],这个比较好想</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>        dp1[<span class="dv">0</span>] =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb21-12"><a href="#cb21-12"></a>        dp1[<span class="dv">1</span>] =<span class="st"> </span>nums[<span class="dv">1</span>]</span>
<span id="cb21-13"><a href="#cb21-13"></a>        dp2[<span class="dv">0</span>] =<span class="st"> </span>nums[<span class="dv">0</span>]</span>
<span id="cb21-14"><a href="#cb21-14"></a>        dp2[<span class="dv">1</span>] =<span class="st"> </span><span class="kw">max</span>(nums[<span class="dv">0</span>],nums[<span class="dv">1</span>])</span>
<span id="cb21-15"><a href="#cb21-15"></a>        <span class="co"># 按照【打家劫舍 I】的转移方式执行两遍</span></span>
<span id="cb21-16"><a href="#cb21-16"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">2</span>,n)<span class="op">:</span></span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="st">            </span>dp1[i] =<span class="st"> </span><span class="kw">max</span>(dp1[i<span class="dv">-1</span>],dp1[i<span class="dv">-2</span>]<span class="op">+</span>nums[i])</span>
<span id="cb21-18"><a href="#cb21-18"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">2</span>,n<span class="dv">-1</span>)<span class="op">:</span></span>
<span id="cb21-19"><a href="#cb21-19"></a><span class="st">            </span>dp2[i] =<span class="st"> </span><span class="kw">max</span>(dp2[i<span class="dv">-1</span>],dp2[i<span class="dv">-2</span>]<span class="op">+</span>nums[i])</span>
<span id="cb21-20"><a href="#cb21-20"></a>        return <span class="kw">max</span>(dp1[<span class="op">-</span><span class="dv">1</span>],dp2[<span class="op">-</span><span class="dv">2</span>])</span></code></pre></div>
<p>进阶题</p>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>示例 1:</p>
<p>输入: [3,2,3,null,3,null,1]</p>
<pre><code> 3
/ \</code></pre>
<p>2 3
   
3 1</p>
<p>输出: 7
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
示例 2:</p>
<p>输入: [3,4,5,1,3,null,1]</p>
<p>  3
/<br />
4 5
/    
1 3 1</p>
<p>输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</p>
<p>哎，这个小偷太能想了==</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="co"># Definition for a binary tree node.</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="co"># class TreeNode:</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="co">#     def __init__(self, x):</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="co">#         self.val = x</span></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="co">#         self.left = None</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="co">#         self.right = None</span></span>
<span id="cb23-8"><a href="#cb23-8"></a></span>
<span id="cb23-9"><a href="#cb23-9"></a>class Solution<span class="op">:</span></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="st">    </span>def <span class="kw">rob</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="st">        </span>return <span class="kw">self.helper</span>(root)[<span class="dv">1</span>]</span>
<span id="cb23-12"><a href="#cb23-12"></a>    </span>
<span id="cb23-13"><a href="#cb23-13"></a>    <span class="co"># helper函数返回一个节点为根的最大值 = [当前节点不参与计算的最大收益，当前节点的最大收益(参与/不参与)]</span></span>
<span id="cb23-14"><a href="#cb23-14"></a>    def <span class="kw">helper</span>(self, root)<span class="op">:</span></span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="st">        </span><span class="cf">if</span> root is None<span class="op">:</span></span>
<span id="cb23-16"><a href="#cb23-16"></a><span class="st">            </span>return [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb23-17"><a href="#cb23-17"></a>        left_amount =<span class="st"> </span><span class="kw">self.helper</span>(root.left)</span>
<span id="cb23-18"><a href="#cb23-18"></a>        right_amount =<span class="st"> </span><span class="kw">self.helper</span>(root.right)</span>
<span id="cb23-19"><a href="#cb23-19"></a>        withoutRoot =<span class="st"> </span>left_amount[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>right_amount[<span class="dv">1</span>]</span>
<span id="cb23-20"><a href="#cb23-20"></a>        withRoot =<span class="st"> </span>root.val <span class="op">+</span><span class="st"> </span>left_amount[<span class="dv">0</span>] <span class="op">+</span><span class="st"> </span>right_amount[<span class="dv">0</span>]</span>
<span id="cb23-21"><a href="#cb23-21"></a>        return [withoutRoot, <span class="kw">max</span>(withRoot, withoutRoot)]</span>
<span id="cb23-22"><a href="#cb23-22"></a></span></code></pre></div>
</div>
<div id="编辑距离" class="section level2" number="1.15">
<h2><span class="header-section-number">1.15</span> 编辑距离</h2>
<blockquote>
<p>给你两个单词word1 和word2，请你计算出将word1转换成word2 所使用的最少操作数。</p>
</blockquote>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符
删除一个字符
替换一个字符</p>
<p>示例1：</p>
<p>输入：word1 = “horse”, word2 = “ros”
输出：3
解释：
horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)
rorse -&gt; rose (删除 ‘r’)
rose -&gt; ros (删除 ‘e’)
示例2：</p>
<p>输入：word1 = “intention”, word2 = “execution”
输出：5
解释：
intention -&gt; inention (删除 ‘t’)
inention -&gt; enention (将 ‘i’ 替换为 ‘e’)
enention -&gt; exention (将 ‘n’ 替换为 ‘x’)
exention -&gt; exection (将 ‘n’ 替换为 ‘c’)
exection -&gt; execution (插入 ‘u’)</p>
<p>解题思路：</p>
<p><img src="../figs/dp_1.png" /></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a></span>
<span id="cb24-2"><a href="#cb24-2"></a>class Solution<span class="op">:</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="st">    </span>def <span class="kw">minDistance</span>(self, word1<span class="op">:</span><span class="st"> </span>str, word2<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="st">        </span>dp =<span class="st"> </span>[[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span>(<span class="kw">len</span>(word2)<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(word1)<span class="op">+</span><span class="dv">1</span>)] <span class="co"># 二维数据的定义</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(word1)<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="st">            </span>dp[i][<span class="dv">0</span>] =<span class="st"> </span>i <span class="co"># word2不存在的时候</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>        <span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(word2)<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="st">            </span>dp[<span class="dv">0</span>][j] =<span class="st"> </span>j <span class="co">#word1不存在的时候</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, <span class="kw">len</span>(word1)<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, <span class="kw">len</span>(word2)<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="st">                </span><span class="cf">if</span> word1[i<span class="dv">-1</span>] <span class="op">==</span><span class="st"> </span>word2[j<span class="dv">-1</span>]<span class="op">:</span><span class="st"> </span><span class="co">#两个词的长度一样的时候</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="st">                    </span>dp[i][j] =<span class="st"> </span>dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>]</span>
<span id="cb24-13"><a href="#cb24-13"></a>                <span class="cf">else</span><span class="op">:</span></span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="st">                    </span>dp[i][j] =<span class="st"> </span><span class="kw">min</span>(dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>], dp[i<span class="dv">-1</span>][j], dp[i][j<span class="dv">-1</span>]) <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb24-15"><a href="#cb24-15"></a>        return dp[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
</div>
<div id="鸡蛋掉落" class="section level2" number="1.16">
<h2><span class="header-section-number">1.16</span> 鸡蛋掉落</h2>
<ul>
<li>背包问题</li>
</ul>
<p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p>
<p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p>
<p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p>
<p> 
示例 1：</p>
<p>输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
如果它没碎，那么肯定能得出 f = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
示例 2：</p>
<p>输入：k = 2, n = 6
输出：3
示例 3：</p>
<p>输入：k = 3, n = 14
输出：4</p>
<p>思路：此题来源是Google的算法面试题，是一个典型的动态规划问题。</p>
<p>首先，根据题设，我们可以知道的是，鸡蛋在某一楼层摔破和没有摔破，可以提供的信息是：没有摔破，表示需要往上层找，直到找到一个摔破的楼层；谁摔破了需要往下层找，知道找到一个没有摔破的楼层。</p>
<p>令二维数组dp[K][Step], K表示鸡蛋个数，Step表示第几次摔落。dp[i][j] 表示 i 个鸡蛋经过 j 次摔落最多可以确定多少层楼。</p>
<p>显然 j &lt;= N。求d[i][j]：</p>
<ul>
<li><p>当第j次摔落，鸡蛋不破，我们可以继续往上确定 dp[i][j -1] 层</p></li>
<li><p>当第j次摔落，鸡蛋破了，我们最多只能确定 dp[i -1][j -1] 层</p></li>
</ul>
<p>状态方程 d[i][j] = dp[i-1][j -1] + (dp[i][j -1] + 1) 最后的1表示本层
<a href="https://blog.csdn.net/weixin_42077402/article/details/96475104">「小布归来了」</a></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="st">    </span>def <span class="kw">superEggDrop</span>(self, K, N)<span class="op">:</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="st">        </span><span class="co"># 构建二维数组dp</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="st">        </span>dp =<span class="st"> </span>[[<span class="dv">0</span> <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(N <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)] <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(K <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)]</span>
<span id="cb25-5"><a href="#cb25-5"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, K <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="st">            </span><span class="cf">for</span> step <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, N <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="st">                </span>dp[i][step] =<span class="st"> </span>dp[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>][step <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>(dp[i][step <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb25-8"><a href="#cb25-8"></a>                <span class="cf">if</span> dp[K][step] <span class="op">&gt;=</span><span class="st"> </span>N<span class="op">:</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="st">                    </span>return step</span>
<span id="cb25-10"><a href="#cb25-10"></a>        return <span class="dv">0</span></span></code></pre></div>
</div>
<div id="整数拆分" class="section level2" number="1.17">
<h2><span class="header-section-number">1.17</span> 整数拆分</h2>
<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。返回你可以获得的最大乘积。</p>
<p>示例 1: 输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。</p>
<p>示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。</p>
<p>这道题拿到很容易去想拆成3个还是4个，以下题解参考代码随想录</p>
<p>动规五部曲，分析如下：</p>
<p>确定dp数组（dp table）以及下标的含义
dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p>
<p>dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！</p>
<p>确定递推公式
可以想 dp[i]最大乘积是怎么得到的呢？</p>
<p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p>
<p>一个是j * (i - j) 直接相乘。</p>
<p>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</p>
<p>那有同学问了，j怎么就不拆分呢？</p>
<p>j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。</p>
<p>那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。</p>
<p>递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</p>
<p>dp的初始化
不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？</p>
<p>有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p>
<p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p>
<p>拆分0和拆分1的最大乘积是多少？</p>
<p>这是无解的。</p>
<p>这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p>
<p>确定遍历顺序
确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</p>
<p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p>
<p>枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。</p>
<p>创建数组dp，长度是n+1，dp[i]表示数字i拆分后加数最大乘积；将前两个数字初始化为0，因为零和1都不能拆分。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a>class Solution<span class="op">:</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="st">    </span>def <span class="kw">integerBreak</span>(self, n<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="st">        </span>dp =<span class="st"> </span>[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span>(n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb26-4"><a href="#cb26-4"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">2</span>, n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(i)<span class="op">:</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="st">                </span>dp[i] =<span class="st"> </span><span class="kw">max</span>(dp[i], j <span class="op">*</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>j), j <span class="op">*</span><span class="st"> </span>dp[i <span class="op">-</span><span class="st"> </span>j])</span>
<span id="cb26-7"><a href="#cb26-7"></a>        return dp[n]</span></code></pre></div>
</div>
<div id="分割等和子集" class="section level2" number="1.18">
<h2><span class="header-section-number">1.18</span> 分割等和子集</h2>
<p>题目描述：</p>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:
每个数组中的元素不会超过 100
数组的大小不会超过 200</p>
<p>示例 1:
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
示例 2:
输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.</p>
<p>解题思路：
参考代码随想录：
如果要是能拆分成两个等和子集，说明和等于“数组之和除以2”</p>
<p>target=sum(ALL)//2动规五部曲分析如下：</p>
<p>确定dp数组以及下标的含义
01背包中，dp[i] 表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>套到本题，dp[i]表示 背包总容量是i，最大可以凑成i的子集总和为dp[i]。</p>
<p>确定递推公式
01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p>
<p>所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p>
<p>dp数组如何初始化
在01背包，一维dp如何初始化，已经讲过，</p>
<p>从dp[j]的定义来看，首先dp[0]一定是0。</p>
<p>如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p>
<p>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。</p>
<p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。</p>
<p>举例推导dp数组
dp[i]的数值一定是小于等于i的。</p>
<p>如果dp[i] == i 说明，集合中的子集总和正好可以凑成总和i，理解这一点很重要。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>class Solution<span class="op">:</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="st">    </span>def <span class="kw">canPartition</span>(self, nums<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>bool<span class="op">:</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="st">        </span>taraget =<span class="st"> </span><span class="kw">sum</span>(nums)</span>
<span id="cb27-4"><a href="#cb27-4"></a>        <span class="cf">if</span> taraget % <span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="st"> </span>return False</span>
<span id="cb27-5"><a href="#cb27-5"></a>        taraget <span class="op">/</span><span class="er">/=</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>        dp =<span class="st"> </span>[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span><span class="dv">10001</span></span>
<span id="cb27-7"><a href="#cb27-7"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(nums))<span class="op">:</span></span>
<span id="cb27-8"><a href="#cb27-8"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(taraget, nums[i] <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dv">-1</span>)<span class="op">:</span></span>
<span id="cb27-9"><a href="#cb27-9"></a><span class="st">                </span>dp[j] =<span class="st"> </span><span class="kw">max</span>(dp[j], dp[j <span class="op">-</span><span class="st"> </span>nums[i]] <span class="op">+</span><span class="st"> </span>nums[i])</span>
<span id="cb27-10"><a href="#cb27-10"></a>        return taraget <span class="op">==</span><span class="st"> </span>dp[taraget]</span></code></pre></div>
</div>
<div id="最长公共子序列" class="section level2" number="1.19">
<h2><span class="header-section-number">1.19</span> 最长公共子序列</h2>
<p>问题描述：</p>
<p>给定两个字符串A和B，返回两个字符串的最长公共子序列，并记录最长公共子序列的长度。例如，两个字符串A、B分别为“1A2C3D4B56”和“B1D23CA45B6A”，则“123456”和“12C4B6”都是最长公共子序列，且最长公共子序列长度为6。（最长公共子序列可能不唯一，但长度唯一。）</p>
<p><img src="../figs/gonggongzixulie.jpg" /></p>
<p>难点在于想明白两种情况。</p>
<p>np.zero()好用的</p>
<p>看下道题，同类型的题目，没意思。。</p>
</div>
<div id="最长重复子数组" class="section level2" number="1.20">
<h2><span class="header-section-number">1.20</span> 最长重复子数组</h2>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例 1:</p>
<p>输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3
解释:
长度最长的公共子数组是 [3, 2, 1]。</p>
<p>1 &lt;= len(A), len(B) &lt;= 1000
0 &lt;= A[i], B[i] &lt; 100</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a><span class="co"># 动态规划</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>class Solution<span class="op">:</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="st">    </span>def <span class="kw">findLength</span>(self, A<span class="op">:</span><span class="st"> </span>List[int], B<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="st">        </span><span class="co">#dp[i][j] = longest(A[:i],B[:j])</span></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="st">        </span>res =<span class="st"> </span><span class="op">-</span><span class="kw">float</span>(<span class="st">&#39;inf&#39;</span>)</span>
<span id="cb28-6"><a href="#cb28-6"></a>        dp =<span class="st"> </span>[[<span class="dv">0</span> <span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(B)<span class="op">+</span><span class="dv">1</span>)] <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(A)<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb28-7"><a href="#cb28-7"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,<span class="kw">len</span>(A)<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,<span class="kw">len</span>(B)<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb28-9"><a href="#cb28-9"></a><span class="st">                </span><span class="cf">if</span> A[i<span class="dv">-1</span>] <span class="op">==</span><span class="st"> </span>B[j<span class="dv">-1</span>]<span class="op">:</span></span>
<span id="cb28-10"><a href="#cb28-10"></a><span class="st">                    </span>dp[i][j] =<span class="st"> </span>dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>] <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>                <span class="cf">else</span><span class="op">:</span></span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="st">                    </span>dp[i][j] =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb28-13"><a href="#cb28-13"></a>                res =<span class="st"> </span><span class="kw">max</span>(dp[i][j],res)</span>
<span id="cb28-14"><a href="#cb28-14"></a>        return res</span></code></pre></div>
</div>
<div id="最大正方形" class="section level2" number="1.21">
<h2><span class="header-section-number">1.21</span> 最大正方形</h2>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a>输入<span class="op">:</span><span class="st"> </span></span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span></span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span></span>
<span id="cb29-7"><a href="#cb29-7"></a></span>
<span id="cb29-8"><a href="#cb29-8"></a>输出<span class="op">:</span><span class="st"> </span><span class="dv">4</span></span></code></pre></div>
<p>典型的动态规划，定义好状态</p>
<p>看到一个解析不错</p>
<p><img src="../figs/zuidasquare.png" /></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a>class Solution<span class="op">:</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="st">    </span>def <span class="kw">maximalSquare</span>(self, matrix<span class="op">:</span><span class="st"> </span>List[List[str]]) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="st">        </span><span class="cf">if</span> <span class="kw">len</span>(matrix) <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>        </span>
<span id="cb30-6"><a href="#cb30-6"></a>        rows =<span class="st"> </span><span class="kw">len</span>(matrix)</span>
<span id="cb30-7"><a href="#cb30-7"></a>        cols =<span class="st"> </span><span class="kw">len</span>(matrix[<span class="dv">0</span>])</span>
<span id="cb30-8"><a href="#cb30-8"></a>        </span>
<span id="cb30-9"><a href="#cb30-9"></a>        max_side =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb30-10"><a href="#cb30-10"></a>        dp =<span class="st"> </span>[[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span>cols <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(rows)]</span>
<span id="cb30-11"><a href="#cb30-11"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(rows)<span class="op">:</span></span>
<span id="cb30-12"><a href="#cb30-12"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(cols)<span class="op">:</span></span>
<span id="cb30-13"><a href="#cb30-13"></a><span class="st">                </span><span class="co"># 当前的值为 1 时，考虑求构成正方形的最长边</span></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="st">                </span><span class="cf">if</span> matrix[i][j] <span class="op">==</span><span class="st"> &#39;1&#39;</span><span class="op">:</span></span>
<span id="cb30-15"><a href="#cb30-15"></a><span class="st">                    </span><span class="co"># 当前值为 1，处于首行首列时，不考虑左，上，左上三个方向</span></span>
<span id="cb30-16"><a href="#cb30-16"></a><span class="st">                    </span><span class="cf">if</span> i <span class="op">==</span><span class="st"> </span><span class="dv">0</span> or j <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb30-17"><a href="#cb30-17"></a><span class="st">                        </span>dp[i][j] =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb30-18"><a href="#cb30-18"></a>                    <span class="cf">else</span><span class="op">:</span></span>
<span id="cb30-19"><a href="#cb30-19"></a><span class="st">                        </span>dp[i][j] =<span class="st"> </span><span class="kw">min</span>(dp[i<span class="dv">-1</span>][j], dp[i<span class="dv">-1</span>][j<span class="dv">-1</span>], dp[i][j<span class="dv">-1</span>]) <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb30-20"><a href="#cb30-20"></a>                    max_side =<span class="st"> </span><span class="kw">max</span>(max_side, dp[i][j])</span>
<span id="cb30-21"><a href="#cb30-21"></a>        </span>
<span id="cb30-22"><a href="#cb30-22"></a>        square =<span class="st"> </span>max_side <span class="op">**</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb30-23"><a href="#cb30-23"></a>        return square</span></code></pre></div>
</div>
<div id="母牛生产一" class="section level2" number="1.22">
<h2><span class="header-section-number">1.22</span> 母牛生产一</h2>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="co">#File Name : 母牛问题.py</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="co"># 开始有一只母牛 母牛每年可以生一只母牛</span></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="co"># 新出生三年后才能每年生一只母牛  假设都不会死</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="co"># 第n年有几只</span></span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a>def <span class="kw">cowNum</span>(N)<span class="op">:</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="st">    </span><span class="cf">if</span> N<span class="op">&lt;=</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="st">        </span>return <span class="dv">1</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    return <span class="kw">cowNum</span>(N<span class="dv">-1</span>)<span class="op">+</span><span class="kw">cowNum</span>(N<span class="dv">-3</span>)</span>
<span id="cb32-5"><a href="#cb32-5"></a> </span>
<span id="cb32-6"><a href="#cb32-6"></a>a =<span class="st"> </span><span class="kw">cowNum</span>(<span class="dv">7</span>)</span>
<span id="cb32-7"><a href="#cb32-7"></a><span class="kw">print</span>(a)</span>
<span id="cb32-8"><a href="#cb32-8"></a> </span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="co"># f(n) = f(n-1) + f(n-3)</span></span>
<span id="cb32-10"><a href="#cb32-10"></a><span class="co"># 今年的牛 = 去年的牛 + 三年前牛的数量</span></span>
<span id="cb32-11"><a href="#cb32-11"></a><span class="co"># 因为三年前的牛现在每个牛都可以生一只牛</span></span></code></pre></div>
</div>
<div id="母牛生产二" class="section level2" number="1.23">
<h2><span class="header-section-number">1.23</span> 母牛生产二</h2>
<p>母牛从3-7岁初每年会生产1头小母牛，10岁后死亡（10岁仍然存活），假设初始有1头刚出生的母牛，请问第n年有多少头母牛？（年从第一年开始计数）</p>
<p>可以列个表格找找规律</p>
<p>写个1-12岁就查差不多了
边界条件比较多</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a><span class="co"># 母牛生产</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>import sys</span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="cf">for</span> line <span class="cf">in</span> sys.stdin<span class="op">:</span></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="st">    </span>n =<span class="st"> </span><span class="kw">int</span>(line)</span>
<span id="cb33-5"><a href="#cb33-5"></a>    <span class="cf">if</span> n <span class="op">&lt;</span><span class="st"> </span><span class="dv">3</span><span class="op">:</span></span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="st">        </span><span class="kw">print</span>(<span class="st">&#39;1&#39;</span>)</span>
<span id="cb33-7"><a href="#cb33-7"></a>    <span class="cf">else</span><span class="op">:</span></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="st">        </span>opt =<span class="st"> </span>[<span class="dv">0</span> <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)]</span>
<span id="cb33-9"><a href="#cb33-9"></a>        opt[<span class="dv">0</span>] =<span class="st"> </span><span class="dv">-1</span></span>
<span id="cb33-10"><a href="#cb33-10"></a>        opt[<span class="dv">1</span>] =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb33-11"><a href="#cb33-11"></a>        opt[<span class="dv">2</span>] =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb33-12"><a href="#cb33-12"></a></span>
<span id="cb33-13"><a href="#cb33-13"></a>        sum =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb33-14"><a href="#cb33-14"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">3</span>, n<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb33-15"><a href="#cb33-15"></a><span class="st">            </span><span class="cf">if</span> i <span class="op">&gt;=</span><span class="st">  </span><span class="dv">3</span> and i <span class="op">&lt;=</span><span class="dv">7</span><span class="op">:</span></span>
<span id="cb33-16"><a href="#cb33-16"></a><span class="st">                </span>sum =<span class="st"> </span>sum <span class="op">+</span><span class="st"> </span>opt[i <span class="op">-</span><span class="st"> </span><span class="dv">2</span>]</span>
<span id="cb33-17"><a href="#cb33-17"></a>                opt[i] =<span class="st"> </span>sum <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb33-18"><a href="#cb33-18"></a></span>
<span id="cb33-19"><a href="#cb33-19"></a>            elif i <span class="op">&gt;=</span><span class="st"> </span><span class="dv">8</span> and i <span class="op">&lt;=</span><span class="st"> </span><span class="dv">10</span><span class="op">:</span></span>
<span id="cb33-20"><a href="#cb33-20"></a><span class="st">                </span>sum =<span class="st"> </span>sum <span class="op">-</span><span class="st"> </span>opt[i<span class="dv">-7</span>] <span class="op">+</span><span class="st"> </span>opt[i<span class="dv">-2</span>]</span>
<span id="cb33-21"><a href="#cb33-21"></a>                opt[i] =<span class="st"> </span>sum <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb33-22"><a href="#cb33-22"></a></span>
<span id="cb33-23"><a href="#cb33-23"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb33-24"><a href="#cb33-24"></a><span class="st">                </span>sum =<span class="st"> </span>sum <span class="op">-</span><span class="st"> </span>opt[i<span class="dv">-7</span>] <span class="op">+</span><span class="st"> </span>opt[i<span class="dv">-2</span>]</span>
<span id="cb33-25"><a href="#cb33-25"></a>                opt[i] =<span class="st"> </span>sum</span>
<span id="cb33-26"><a href="#cb33-26"></a></span>
<span id="cb33-27"><a href="#cb33-27"></a>        <span class="kw">print</span>(opt[<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div>
</div>
<div id="一和零" class="section level2" number="1.24">
<h2><span class="header-section-number">1.24</span> 一和零</h2>
<ul>
<li>题目描述</li>
</ul>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的大小，该子集中最多有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p>示例 1：</p>
<p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3 输出：4</p>
<p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p>
<p>示例 2： 输入：strs = [“10”, “0”, “1”], m = 1, n = 1 输出：2 解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p>
<p>提示：</p>
<p>1 &lt;= strs.length &lt;= 600
1 &lt;= strs[i].length &lt;= 100
strs[i] 仅由 ‘0’ 和 ‘1’ 组成
1 &lt;= m, n &lt;= 100</p>
<ul>
<li>解题思路</li>
</ul>
<p>参考代码随想录</p>
<p>开始动规五部曲：</p>
<p>确定dp数组（dp table）以及下标的含义
dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。</p>
<p>确定递推公式
dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p>
<p>dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。</p>
<p>然后我们在遍历的过程中，取dp[i][j]的最大值。</p>
<p>所以递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</p>
<p>此时大家可以回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。</p>
<p><strong>这就是一个典型的01背包！ 只不过物品的重量有了两个维度而已。</strong></p>
<p>dp数组如何初始化
在动态规划：关于01背包问题，你该了解这些！（滚动数组）中已经讲解了，01背包的dp数组初始化为0就可以。</p>
<p>因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖。</p>
<p>确定遍历顺序
在动态规划：关于01背包问题，你该了解这些！（滚动数组）中，我们讲到了01背包为什么一定是外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p>
<p>那么本题也是，物品就是strs里的字符串，背包容量就是题目描述中的m和n。</p>
<p>代码如下：</p>
<p>有同学可能想，那个遍历背包容量的两层for循环先后循序有没有什么讲究？</p>
<p><strong>没讲究，都是物品重量的一个维度，先遍历那个都行！</strong></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a>class Solution<span class="op">:</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="st">    </span>def <span class="kw">findMaxForm</span>(self, strs<span class="op">:</span><span class="st"> </span>List[str], m<span class="op">:</span><span class="st"> </span>int, n<span class="op">:</span><span class="st"> </span>int) -&gt;<span class="st"> </span>int<span class="op">:</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="st">        </span>dp =<span class="st"> </span>[[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span>(n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>) <span class="cf">for</span> _ <span class="cf">in</span> <span class="kw">range</span>(m <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)]  <span class="co"># 默认初始化0</span></span>
<span id="cb34-4"><a href="#cb34-4"></a>        <span class="co"># dp=np.zero(m+1,n+1)</span></span>
<span id="cb34-5"><a href="#cb34-5"></a>        <span class="co"># 遍历物品</span></span>
<span id="cb34-6"><a href="#cb34-6"></a>        <span class="cf">for</span> str <span class="cf">in</span> strs<span class="op">:</span></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="st">            </span>ones =<span class="st"> </span><span class="kw">str.count</span>(<span class="st">&#39;1&#39;</span>)</span>
<span id="cb34-8"><a href="#cb34-8"></a>            zeros =<span class="st"> </span><span class="kw">str.count</span>(<span class="st">&#39;0&#39;</span>)</span>
<span id="cb34-9"><a href="#cb34-9"></a>            <span class="co"># 遍历背包容量且从后向前遍历！</span></span>
<span id="cb34-10"><a href="#cb34-10"></a>            <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(m, zeros <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dv">-1</span>)<span class="op">:</span></span>
<span id="cb34-11"><a href="#cb34-11"></a><span class="st">                </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(n, ones <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dv">-1</span>)<span class="op">:</span></span>
<span id="cb34-12"><a href="#cb34-12"></a><span class="st">                    </span>dp[i][j] =<span class="st"> </span><span class="kw">max</span>(dp[i][j], dp[i <span class="op">-</span><span class="st"> </span>zeros][j <span class="op">-</span><span class="st"> </span>ones] <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</span>
<span id="cb34-13"><a href="#cb34-13"></a>        return dp[m][n]</span></code></pre></div>
</div>
<div id="最后一块石头一" class="section level2" number="1.25">
<h2><span class="header-section-number">1.25</span> 最后一块石头一</h2>
<ul>
<li>题目描述
每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</li>
</ul>
<p>如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。<strong>返回此石头最小的可能重量</strong>。如果没有石头剩下，就返回 0。</p>
<p>示例：
输入：[2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
提示：
1 &lt;= stones.length &lt;= 30
1 &lt;= stones[i] &lt;= 1000</p>
<ul>
<li>解题思路</li>
</ul>
<p>这个题和分割等和子集非常像了。</p>
<p>本题物品的重量为stone[i]，物品的价值也为stone[i]。</p>
<p>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p>
<p>接下来进行动规五步曲：</p>
<p>确定dp数组以及下标的含义
dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背dp[j]这么重的石头。</p>
<p>确定递推公式
01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>本题则是：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</p>
<p>一些同学可能看到这dp[j - stones[i]] + stones[i]中 又有- stones[i] 又有+stones[i]，看着有点晕乎。</p>
<p>还是要牢记dp[j]的含义，要知道dp[j - stones[i]]为 容量为j - stones[i]的背包最大所背重量。</p>
<p>dp数组如何初始化
既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p>
<p>因为提示中给出1 &lt;= stones.length &lt;= 30，1 &lt;= stones[i] &lt;= 1000，所以最大重量就是30 * 1000 。</p>
<p>而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p>
<p>当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。</p>
<p>我这里就直接用15000了。</p>
<p>接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])中dp[j]才不会初始值所覆盖。</p>
<p>有了递推公式，就很简单了</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1"></a>class Solution<span class="op">:</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="st">    </span>def <span class="kw">canPartition</span>(self, nums<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>bool<span class="op">:</span></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="st">        </span>taraget =<span class="st"> </span><span class="kw">sum</span>(nums)</span>
<span id="cb35-4"><a href="#cb35-4"></a>        sum=<span class="dv">0</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>        <span class="cf">if</span> taraget % <span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="st"> </span>return False</span>
<span id="cb35-6"><a href="#cb35-6"></a>        taraget <span class="op">/</span><span class="er">/=</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>        dp =<span class="st"> </span>[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span><span class="dv">10001</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(nums))<span class="op">:</span></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(taraget, nums[i] <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dv">-1</span>)<span class="op">:</span></span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="st">                </span>dp[j] =<span class="st"> </span><span class="kw">max</span>(dp[j], dp[j <span class="op">-</span><span class="st"> </span>stones[i]] <span class="op">+</span><span class="st"> </span>stones[i])</span>
<span id="cb35-11"><a href="#cb35-11"></a>        return sum <span class="op">-</span><span class="st"> </span>dp[target] <span class="op">-</span><span class="st"> </span>dp[target]</span></code></pre></div>
</div>
<div id="最后一块石头二" class="section level2" number="1.26">
<h2><span class="header-section-number">1.26</span> 最后一块石头二</h2>
<p>有时间再看</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>

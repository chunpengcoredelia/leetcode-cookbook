---
title : 回溯专题
author: 高文欣
date: "`r Sys.Date()`"
output: bookdown::gitbook
bibliography: ../refs/add.bib
---

# 回溯专题

## 定义

参考[【代码随想录】](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.md)

回溯是递归的副产品
- 回溯法解决的问题

- 组合问题：N个数里面按一定规则找出k个数的集合

- 切割问题：一个字符串按一定规则有几种切割方式

- 子集问题：一个N个数的集合里有多少符合条件的子集

- 排列问题：N个数按一定规则全排列，有几种排列方式

- 棋盘问题：N皇后，解数独等等


另外，会有一些同学可能分不清什么是组合，什么是排列？

组合是不强调元素顺序的，排列是强调元素顺序。

例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。

记住组合无序，排列有序，就可以了。

- 如何理解回溯法

>回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。

总之,一句话本质上还是递归，既包含二叉树的前序遍历又包含二叉树的后序遍历。


## 解决方法

主要包含三个点

- 定义路径

- 出口条件

- 做出选择

一般基于模板的变形就是在出口条件和做出选择的地方进行变形


**下面是一个组合问题，也是一个标准化的模板**
```r
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res=[]
        track=[] #路径
        def backtrack(track):
            if len(track)==len(nums):# 出口条件
                res.append(track.copy()) # 
                return 
            for i in nums: # 做选择
                if i not in track:
                    track.append(i)
                    backtrack(track) # 递归
                    track.pop() # 退栈。回溯
        backtrack(track)
        return res
        
```

## 组合问题

- 题目描述
给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:
输入: n = 4, k = 2
输出:
[
[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],
]

- 解题思路
回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。

```r
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res=[]  #存放符合条件结果的集合
        path=[]  #用来存放符合条件结果
        def backtrack(n,k,startIndex):
            if len(path) == k:
                res.append(path[:])
                return 
            for i in range(startIndex,n+1):
                path.append(i)  #处理节点 
                backtrack(n,k,i+1)  #递归
                path.pop()  #回溯，撤销处理的节点
        backtrack(n,k,1)
        return res
```

- copy

这个是浅拷贝，是有关py的底层原理

a=b此时a是拷贝了b的引用

## 组合总和

- 题目描述

给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。

candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 

对于给定的输入，保证和为 target 的唯一组合数少于 150 个。

示例 1：

输入: candidates = [2,3,6,7], target = 7
输出: [[7],[2,2,3]]
示例 2：

输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
示例 3：

输入: candidates = [2], target = 1
输出: []
示例 4：

输入: candidates = [1], target = 1
输出: [[1]]
示例 5：

输入: candidates = [1], target = 2
输出: [[1,1]]

- 解题思路

定义路径
定义出口
选择条件

这道题主要就是在出口和选择条件处做的变形


```r
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res=[]
        track=[]
        def backtrack(track):
            if sum(track)==target:
                res.append(track.copy())
                return 
            if sum(track)>target:
                return 
            for i in candidates:
                if track and i < max(track):
                    continue
                track.append(i)
                backtrack(track)
                track.pop()
        backtrack(track)
        return res
```
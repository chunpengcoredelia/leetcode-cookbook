<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>tree_topic</title>
  <meta name="description" content="tree_topic" />
  <meta name="generator" content="bookdown #bookdown:version# and GitBook 2.6.7" />

  <meta property="og:title" content="tree_topic" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="tree_topic" />
  
  
  

<meta name="author" content="高文欣" />


<meta name="date" content="2021-08-01" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<!--bookdown:link_prev-->
<!--bookdown:link_next-->
<script src="libs/header-attrs-2.2/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



<!--bookdown:title:start-->
<div id="header">
<h1 class="title">tree_topic</h1>
<p class="author"><em>高文欣</em></p>
<p class="date"><em>2021-08-01</em></p>
</div>
<!--bookdown:title:end-->

<!--bookdown:toc:start-->
  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">
<!--bookdown:toc2:start-->
<ul>
<li><a href="#相同的树问题"><span class="toc-section-number">0.0.1</span> 相同的树问题</a></li>
<li><a href="#对称二叉树"><span class="toc-section-number">0.0.2</span> 对称二叉树</a></li>
<li><a href="#二叉树的最大深度"><span class="toc-section-number">0.0.3</span> 二叉树的最大深度</a></li>
<li><a href="#二叉树的最小深度"><span class="toc-section-number">0.0.4</span> 二叉树的最小深度</a></li>
<li><a href="#二叉树的层次遍历"><span class="toc-section-number">0.0.5</span> 二叉树的层次遍历</a></li>
<li><a href="#将有序数组转化为二叉树"><span class="toc-section-number">0.0.6</span> 将有序数组转化为二叉树</a></li>
<li><a href="#平衡二叉树"><span class="toc-section-number">0.0.7</span> 平衡二叉树</a></li>
<li><a href="#路径总和一"><span class="toc-section-number">0.0.8</span> 路径总和一</a></li>
<li><a href="#翻转二叉树"><span class="toc-section-number">0.0.9</span> 翻转二叉树</a></li>
<li><a href="#公共祖先"><span class="toc-section-number">0.0.10</span> 公共祖先</a></li>
<li><a href="#二叉树的所有路径"><span class="toc-section-number">0.0.11</span> 二叉树的所有路径</a></li>
<li><a href="#左叶子之和"><span class="toc-section-number">0.0.12</span> 左叶子之和</a></li>
<li><a href="#路径总和二"><span class="toc-section-number">0.0.13</span> 路径总和二</a></li>
<li><a href="#二叉树的遍历"><span class="toc-section-number">0.1</span> 二叉树的遍历</a></li>
<li><a href="#前序遍历"><span class="toc-section-number">0.2</span> 前序遍历</a></li>
<li><a href="#中序遍历"><span class="toc-section-number">0.3</span> 中序遍历</a></li>
<li><a href="#二叉树的层次遍历-1"><span class="toc-section-number">0.4</span> 二叉树的层次遍历</a></li>
<li><a href="#前序中序后序遍历"><span class="toc-section-number">0.5</span> 前序中序后序遍历</a></li>
<li><a href="#堆排序"><span class="toc-section-number">0.6</span> 堆排序</a></li>
<li><a href="#霍夫曼树"><span class="toc-section-number">0.7</span> 霍夫曼树</a></li>
<li><a href="#二叉树遍历总结"><span class="toc-section-number">0.8</span> 二叉树遍历总结</a></li>
</ul>
<!--bookdown:toc2:end-->
      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">tree_topic</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:toc:end-->
<!--bookdown:body:start-->
<p>懵逼树上懵逼果，懵逼树下只有我。。。
一直寻找一个合适的leetcode的刷题顺序，不少大佬都推荐从二叉树开始刷。一开始心里是发怵的，从之前的发怵经验来看，所有事情都有一个从0到1的过程。第一遍感觉挺懵逼的，所以打算来第二遍，这一次我一定会放慢速度，好好理解的。</p>
<ul>
<li>root.val是该节点的值。</li>
<li>root则相当于指向该节点的指针。</li>
<li>root.left, root.right指向其左右节点的位置</li>
</ul>
<p>val=values
left,right就是位置</p>
<p>二叉树节点的定义</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co"># Definition for a binary tree node.</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>class <span class="kw">TreeNode</span>(object)<span class="op">:</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="st">    </span>def <span class="kw">__init__</span>(self, x)<span class="op">:</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="st">        </span>self.val =<span class="st"> </span>x</span>
<span id="cb1-6"><a href="#cb1-6"></a>        self.left =<span class="st"> </span>None</span>
<span id="cb1-7"><a href="#cb1-7"></a>        self.right =<span class="st"> </span>None</span></code></pre></div>
<p>还是得结合二叉树主要解决了什么实际的问题</p>
<p>树为啥这么好用？</p>
<p><a href="https://zhuanlan.zhihu.com/p/63419145">知乎</a></p>
<div id="相同的树问题" class="section level3" number="0.0.1">
<h3 number="0.0.1"><span class="header-section-number">0.0.1</span> 相同的树问题</h3>
<div class="figure">
<img src="figs/xaingtongtree.png" alt="" />
<p class="caption">相同的树</p>
</div>
<p>判断两个树是否为相同的树</p>
<p>解题思路：两个树的结构相同，节点相同则相同,或者都为空也相同
递归
假入有2棵树p,q</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="st">    </span>def <span class="kw">isSameTree</span>(self, p, q)<span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="st">        </span><span class="cf">if</span> p is None and q is None<span class="op">:</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="st">            </span>return True</span>
<span id="cb2-6"><a href="#cb2-6"></a>        <span class="cf">if</span> p is not None and q is not None<span class="op">:</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="st">            </span>return p.val<span class="op">==</span>q.val and <span class="kw">self.isSameTree</span>(p.left,q.left) and <span class="kw">self.isSameTree</span>(p.right,q.right)</span>
<span id="cb2-8"><a href="#cb2-8"></a>        return False</span></code></pre></div>
</div>
<div id="对称二叉树" class="section level3" number="0.0.2">
<h3 number="0.0.2"><span class="header-section-number">0.0.2</span> 对称二叉树</h3>
<div class="figure">
<img src="figs/duichentree.png" alt="" />
<p class="caption">对称的树</p>
</div>
<blockquote>
<p>首先判断头结点是否为空。然后<strong>将根节点的左右两个节点假设成两个独立的树</strong>，如果左右两个树都为空，返回True。然后看左子树的左结点和右子树的右结点、左子树的右结点和右子树的左结点是否相同，都相同返回True.</p>
</blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="st">    </span>def <span class="kw">isSymmetric</span>(self, root)<span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="st">        </span><span class="cf">if</span> root is None<span class="op">:</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="st">            </span>return True</span>
<span id="cb3-6"><a href="#cb3-6"></a>        return <span class="kw">self.isSymmetricTree</span>(root.left,root.right)</span>
<span id="cb3-7"><a href="#cb3-7"></a>    def <span class="kw">isSymmetricTree</span>(self,left,right)<span class="op">:</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="st">        </span><span class="cf">if</span> left is None and right is None<span class="op">:</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="st">            </span>return True</span>
<span id="cb3-10"><a href="#cb3-10"></a>        <span class="cf">if</span> left is None or right is None or left.val <span class="op">!=</span><span class="st"> </span>right.val<span class="op">:</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="st">            </span>return False</span>
<span id="cb3-12"><a href="#cb3-12"></a>        return <span class="kw">self.isSymmetricTree</span>(left.left,right.right) and <span class="kw">self.isSymmetricTree</span>(left.right,right.left)</span></code></pre></div>
</div>
<div id="二叉树的最大深度" class="section level3" number="0.0.3">
<h3 number="0.0.3"><span class="header-section-number">0.0.3</span> 二叉树的最大深度</h3>
<div class="figure">
<img src="figs/deepth.png" alt="" />
<p class="caption">相同的树</p>
</div>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="st">    </span>def <span class="kw">maxDepth</span>(self, root)<span class="op">:</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="st">        </span><span class="cf">if</span> root is None<span class="op">:</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="st">            </span>return <span class="kw">max</span>(<span class="kw">self.maxDepth</span>(root.left),<span class="kw">self.maxDepth</span>(root.right))<span class="op">+</span><span class="dv">1</span></span></code></pre></div>
</div>
<div id="二叉树的最小深度" class="section level3" number="0.0.4">
<h3 number="0.0.4"><span class="header-section-number">0.0.4</span> 二叉树的最小深度</h3>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="st">    </span>def <span class="kw">minDepth</span>(self, root)<span class="op">:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="st">       </span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="st">        </span><span class="cf">if</span> root is None<span class="op">:</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>        <span class="cf">if</span> root.left and root.right<span class="op">:</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="st">            </span>return <span class="kw">min</span>(<span class="kw">self.minDepth</span>(root.left),<span class="kw">self.minDepth</span>(root.right))<span class="op">+</span><span class="dv">1</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="st">            </span>return <span class="kw">max</span>(<span class="kw">self.minDepth</span>(root.left),<span class="kw">self.minDepth</span>(root.right))<span class="op">+</span><span class="dv">1</span> <span class="co">#根节点只有一个节点的时候</span></span></code></pre></div>
</div>
<div id="二叉树的层次遍历" class="section level3" number="0.0.5">
<h3 number="0.0.5"><span class="header-section-number">0.0.5</span> 二叉树的层次遍历</h3>
<p><img src="figs/cengcibianli.png" alt="层次遍历" />
给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>定义两个数组，一个level的，一个level装节点的</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="st">    </span>def <span class="kw">levelOrderBottom</span>(self, root)<span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="st">        </span><span class="cf">if</span> root is None<span class="op">:</span><span class="st"> </span><span class="co">#根节点不为空</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="st">            </span>return []</span>
<span id="cb6-6"><a href="#cb6-6"></a>        </span>
<span id="cb6-7"><a href="#cb6-7"></a>        result,current =<span class="st"> </span>[],[root] <span class="co">#当前节点在root</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>        </span>
<span id="cb6-9"><a href="#cb6-9"></a>        <span class="cf">while</span> current<span class="op">:</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="st">            </span>next_level,vals =<span class="st"> </span>[], []</span>
<span id="cb6-11"><a href="#cb6-11"></a>            <span class="cf">for</span> node <span class="cf">in</span> current<span class="op">:</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="st">                </span><span class="kw">vals.append</span>(node.val)</span>
<span id="cb6-13"><a href="#cb6-13"></a>                <span class="cf">if</span> node.left<span class="op">:</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="st">                    </span><span class="kw">next_level.append</span>(node.left)</span>
<span id="cb6-15"><a href="#cb6-15"></a>                <span class="cf">if</span> node.right<span class="op">:</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="st">                    </span><span class="kw">next_level.append</span>(node.right)</span>
<span id="cb6-17"><a href="#cb6-17"></a>            current =<span class="st"> </span>next_level</span>
<span id="cb6-18"><a href="#cb6-18"></a>            <span class="kw">result.append</span>(vals)</span>
<span id="cb6-19"><a href="#cb6-19"></a>        return result[<span class="op">::-</span><span class="dv">1</span>] <span class="co">#从低向上</span></span></code></pre></div>
</div>
<div id="将有序数组转化为二叉树" class="section level3" number="0.0.6">
<h3 number="0.0.6"><span class="header-section-number">0.0.6</span> 将有序数组转化为二叉树</h3>
<div class="figure">
<img src="figs/youxushuzuzhuantree.png" alt="" />
<p class="caption">将有序数组转化为二叉树</p>
</div>
<p>转换为二叉搜索树</p>
<p><strong>取有序数组的中间节点作为根节点，将数组分为左右两个部分，对左右两个子数组做相同的操作，递归的实现</strong>。暴力取中间节点为root：递归实现</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>class Solution<span class="op">:</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="st">    </span>def <span class="kw">sortedArrayToBST</span>(self, nums<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>TreeNode<span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="st">        </span><span class="cf">if</span> nums<span class="op">:</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="st">            </span>m =<span class="st"> </span><span class="kw">len</span>(nums) <span class="op">/</span><span class="er">/</span><span class="st"> </span><span class="dv">2</span> 中间节点为根节点</span>
<span id="cb7-5"><a href="#cb7-5"></a>            r =<span class="st"> </span><span class="kw">TreeNode</span>(nums[m])</span>
<span id="cb7-6"><a href="#cb7-6"></a>            r.left, r.right =<span class="st"> </span><span class="kw">map</span>(self.sortedArrayToBST, [nums[<span class="op">:</span>m], nums[m<span class="op">+</span><span class="dv">1</span><span class="op">:</span>]])</span>
<span id="cb7-7"><a href="#cb7-7"></a>            return r</span></code></pre></div>
</div>
<div id="平衡二叉树" class="section level3" number="0.0.7">
<h3 number="0.0.7"><span class="header-section-number">0.0.7</span> 平衡二叉树</h3>
<p><img src="figs/pinghengtree.png" />
<strong>一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值小于1。</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="st">    </span>def <span class="kw">isBalanced</span>(self, root)<span class="op">:</span></span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="st">        </span><span class="cf">if</span> root <span class="op">==</span><span class="st"> </span>None<span class="op">:</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="st">            </span>return True</span>
<span id="cb8-6"><a href="#cb8-6"></a>        elif <span class="kw">abs</span>(<span class="kw">self.height</span>(root.left)<span class="op">-</span><span class="kw">self.height</span>(root.right))<span class="op">&gt;</span><span class="dv">1</span><span class="op">:</span><span class="st"> </span><span class="co">#高度的绝对值之差大于1，不平衡</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="st">            </span>return False</span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="st">            </span>return <span class="kw">self.isBalanced</span>(root.left) and <span class="kw">self.isBalanced</span>(root.right)</span>
<span id="cb8-10"><a href="#cb8-10"></a>    </span>
<span id="cb8-11"><a href="#cb8-11"></a>    def <span class="kw">height</span>(self,root)<span class="op">:</span><span class="st"> </span><span class="co">#判断是否为平衡</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="st">        </span><span class="cf">if</span> root <span class="op">==</span><span class="st"> </span>None<span class="op">:</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="st">            </span>return <span class="kw">max</span>(<span class="kw">self.height</span>(root.left),<span class="kw">self.height</span>(root.right))<span class="op">+</span><span class="st"> </span><span class="dv">1</span></span></code></pre></div>
</div>
<div id="路径总和一" class="section level3" number="0.0.8">
<h3 number="0.0.8"><span class="header-section-number">0.0.8</span> 路径总和一</h3>
<p><img src="figs/lujingzonghe.png" />
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>从上到下加起来，最后一个节点的值就等于sum-前面的和，且这个节点是叶子节点。</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="st">    </span>def <span class="kw">hasPathSum</span>(self, root, sum)<span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="st">       </span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="st">        </span><span class="cf">if</span> root is None<span class="op">:</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="st">            </span>return False</span>
<span id="cb9-6"><a href="#cb9-6"></a>        <span class="cf">if</span> root.left is None and root.right is None and root.val<span class="op">==</span>sum<span class="op">:</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="st">            </span>return True</span>
<span id="cb9-8"><a href="#cb9-8"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="st">            </span>return <span class="kw">self.hasPathSum</span>(root.left,sum<span class="op">-</span>root.val) or <span class="kw">self.hasPathSum</span>(root.right,sum<span class="op">-</span>root.val)</span></code></pre></div>
</div>
<div id="翻转二叉树" class="section level3" number="0.0.9">
<h3 number="0.0.9"><span class="header-section-number">0.0.9</span> 翻转二叉树</h3>
<p><img src="figs/fanzhuantree.png" /></p>
<p>镜面对换</p>
<p>那就是交换左右节点喽</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="st">    </span>def <span class="kw">invertTree</span>(self, root)<span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="st">        </span><span class="cf">if</span> root is not None<span class="op">:</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="st">            </span>root.left,root.right =<span class="st"> </span><span class="kw">self.invertTree</span>(root.right),<span class="kw">self.invertTree</span>(root.left)</span>
<span id="cb10-6"><a href="#cb10-6"></a>        return root</span></code></pre></div>
</div>
<div id="公共祖先" class="section level3" number="0.0.10">
<h3 number="0.0.10"><span class="header-section-number">0.0.10</span> 公共祖先</h3>
<p>二叉搜索树的最近公共祖先</p>
<p>这个不太明白。。</p>
<p>哦哦哦，这是确定了树，按照此题分析就好了，哈哈，看树的结构，左子树均小于根节点的值，右子树均大于根节点的值</p>
<div class="figure">
<img src="figs/公共祖先.png" alt="" />
<p class="caption">公共祖先描述</p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Definition for a binary tree node.</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co"># class TreeNode(object):</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co">#     def __init__(self, x):</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co">#         self.val = x</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co">#         self.left = None</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co">#         self.right = None</span></span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="st">    </span>def <span class="kw">lowestCommonAncestor</span>(self, root, p, q)<span class="op">:</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="st">        :type root: TreeNode</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="st">        :type p: TreeNode</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="st">        :type q: TreeNode</span></span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="st">        :rtype: TreeNode</span></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>        pointer =<span class="st"> </span>root</span>
<span id="cb11-17"><a href="#cb11-17"></a>        <span class="cf">while</span> pointer<span class="op">:</span></span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="st">            </span><span class="cf">if</span> q.val <span class="op">&lt;</span><span class="st"> </span>pointer.val and p.val <span class="op">&lt;</span><span class="st"> </span>pointer.val<span class="op">:</span></span>
<span id="cb11-19"><a href="#cb11-19"></a><span class="st">                </span>pointer =<span class="st"> </span>pointer.left</span>
<span id="cb11-20"><a href="#cb11-20"></a>            elif q.val <span class="op">&gt;</span><span class="st"> </span>pointer.val and p.val <span class="op">&gt;</span><span class="st"> </span>pointer.val<span class="op">:</span></span>
<span id="cb11-21"><a href="#cb11-21"></a><span class="st">                </span>pointer =<span class="st"> </span>pointer.right</span>
<span id="cb11-22"><a href="#cb11-22"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb11-23"><a href="#cb11-23"></a><span class="st">                </span>return pointer</span></code></pre></div>
</div>
<div id="二叉树的所有路径" class="section level3" number="0.0.11">
<h3 number="0.0.11"><span class="header-section-number">0.0.11</span> 二叉树的所有路径</h3>
<div class="figure">
<img src="figs/所有路径.png" alt="" />
<p class="caption">所有路径</p>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="st">    </span>def <span class="kw">binaryTreePaths</span>(self, root)<span class="op">:</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="st">        :type root: TreeNode</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="st">        :rtype: List[str]</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>        result =<span class="st"> </span><span class="kw">list</span>()</span>
<span id="cb12-8"><a href="#cb12-8"></a>        <span class="cf">if</span> root <span class="op">==</span><span class="st"> </span>None<span class="op">:</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="st">            </span>return result</span>
<span id="cb12-10"><a href="#cb12-10"></a></span>
<span id="cb12-11"><a href="#cb12-11"></a>        <span class="cf">if</span> root.left <span class="op">==</span><span class="st"> </span>None and root.right <span class="op">==</span><span class="st"> </span>None<span class="op">:</span></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="st">            </span><span class="kw">result.append</span>(<span class="kw">str</span>(root.val))</span>
<span id="cb12-13"><a href="#cb12-13"></a>            return result <span class="co"># 保存根节点的值</span></span>
<span id="cb12-14"><a href="#cb12-14"></a></span>
<span id="cb12-15"><a href="#cb12-15"></a>        left =<span class="st"> </span><span class="kw">self.binaryTreePaths</span>(root.left)</span>
<span id="cb12-16"><a href="#cb12-16"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(left))<span class="op">:</span></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="st">            </span><span class="kw">result.append</span>(<span class="kw">str</span>(root.val) <span class="op">+</span><span class="st"> &#39;-&gt;&#39;</span> <span class="op">+</span><span class="st"> </span>left[i]) <span class="co">#遍历一遍左节点</span></span>
<span id="cb12-18"><a href="#cb12-18"></a></span>
<span id="cb12-19"><a href="#cb12-19"></a>        right =<span class="st"> </span><span class="kw">self.binaryTreePaths</span>(root.right) <span class="co">#遍历一遍右节点</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(right))<span class="op">:</span></span>
<span id="cb12-21"><a href="#cb12-21"></a><span class="st">            </span><span class="kw">result.append</span>(<span class="kw">str</span>(root.val) <span class="op">+</span><span class="st"> &#39;-&gt;&#39;</span> <span class="op">+</span><span class="st"> </span>right[i])</span>
<span id="cb12-22"><a href="#cb12-22"></a></span>
<span id="cb12-23"><a href="#cb12-23"></a>        return result</span></code></pre></div>
</div>
<div id="左叶子之和" class="section level3" number="0.0.12">
<h3 number="0.0.12"><span class="header-section-number">0.0.12</span> 左叶子之和</h3>
<div class="figure">
<img src="figs/左叶子之和.png" alt="" />
<p class="caption">左叶子之和</p>
</div>
<p>也就是左子树的叶子节点的值与右子树左叶子叶子节点的值</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="st">    </span>def <span class="kw">sumOfLeftLeaves</span>(self, root)<span class="op">:</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="st">        :type root: TreeNode</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="st">        :rtype: int</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>        result =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>        <span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="st">            </span>return <span class="dv">0</span>      </span>
<span id="cb13-10"><a href="#cb13-10"></a>        <span class="cf">if</span> root.left and not root.left.left and not root.left.right<span class="op">:</span></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="st">            </span>result <span class="op">+</span><span class="er">=</span><span class="st"> </span>root.left.val</span>
<span id="cb13-12"><a href="#cb13-12"></a>        return result<span class="op">+</span><span class="kw">self.sumOfLeftLeaves</span>(root.left)<span class="op">+</span><span class="kw">self.sumOfLeftLeaves</span>(root.right) </span></code></pre></div>
</div>
<div id="路径总和二" class="section level3" number="0.0.13">
<h3 number="0.0.13"><span class="header-section-number">0.0.13</span> 路径总和二</h3>
<div class="figure">
<img src="figs/路径总和.png" alt="" />
<p class="caption">路径总和</p>
</div>
<p>利用递归，当root为None时，返回False，当root的值等于sum且root为叶节点时，返回true，如果不相等，往下递归，只要左子树和右子树有一条路径即可返回True</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="st">    </span>def <span class="kw">pathSum</span>(self, root, sum)<span class="op">:</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="st">        :type root: TreeNode</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="st">        :type sum: int</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="st">        :rtype: int</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>        <span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>        return <span class="kw">self.pathSumFrom</span>(root, sum) <span class="op">+</span><span class="st"> </span><span class="kw">self.pathSum</span>(root.left, sum) <span class="op">+</span><span class="st"> </span><span class="kw">self.pathSum</span>(root.right, sum)</span>
<span id="cb14-11"><a href="#cb14-11"></a></span>
<span id="cb14-12"><a href="#cb14-12"></a>    def <span class="kw">pathSumFrom</span>(self, node, sum)<span class="op">:</span></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="st">        </span><span class="cf">if</span> not node<span class="op">:</span></span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb14-15"><a href="#cb14-15"></a>        <span class="kw">return</span> (<span class="dv">1</span> <span class="cf">if</span> node.val <span class="op">==</span><span class="st"> </span>sum <span class="cf">else</span> <span class="dv">0</span>) <span class="op">+</span><span class="st"> </span><span class="kw">self.pathSumFrom</span>(node.left, sum <span class="op">-</span><span class="st"> </span>node.val) <span class="op">+</span><span class="st"> </span><span class="kw">self.pathSumFrom</span>(node.right, sum <span class="op">-</span><span class="st"> </span>node.val)</span>
<span id="cb14-16"><a href="#cb14-16"></a>        </span>
<span id="cb14-17"><a href="#cb14-17"></a>        </span></code></pre></div>
</div>
<div id="二叉树的遍历" class="section level2" number="0.1">
<h2 number="0.1"><span class="header-section-number">0.1</span> 二叉树的遍历</h2>
<p>二叉树这里还是可以多使用一点递归的方法</p>
</div>
<div id="前序遍历" class="section level2" number="0.2">
<h2 number="0.2"><span class="header-section-number">0.2</span> 前序遍历</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>class <span class="kw">Solution</span>(object)<span class="op">:</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="st">    </span>def <span class="kw">__init__</span>(self)<span class="op">:</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="st">        </span>self.res =<span class="st"> </span>[]</span>
<span id="cb15-4"><a href="#cb15-4"></a>    def <span class="kw">preorderTraversal</span>(self, root)<span class="op">:</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="st">        :type root: TreeNode</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="st">        :rtype: List[int]</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="st">        &quot;&quot;&quot;</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>        <span class="cf">if</span> root <span class="op">==</span><span class="st"> </span>None<span class="op">:</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="st">            </span>return []</span>
<span id="cb15-11"><a href="#cb15-11"></a>        <span class="kw">self.res.append</span>(root.val)<span class="co">#每次遍历到根结点就把它加到队列中</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>        <span class="kw">self.preorderTraversal</span>(root.left)<span class="co">#当有左节点的时候就处理左节点</span></span>
<span id="cb15-13"><a href="#cb15-13"></a>        <span class="kw">self.preorderTraversal</span>(root.right)<span class="co">#当同级没有左节点的时候再处理右节点</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>        return self.res</span></code></pre></div>
</div>
<div id="中序遍历" class="section level2" number="0.3">
<h2 number="0.3"><span class="header-section-number">0.3</span> 中序遍历</h2>
<p>给定一个二叉树，返回它的中序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]
1<br />
2
/
3</p>
<p>输出: [1,3,2]</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># Definition for a binary tree node.</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co"># class TreeNode:</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">#     def __init__(self, x):</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">#         self.val = x</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co">#         self.left = None</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">#         self.right = None</span></span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a>class Solution<span class="op">:</span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="st">    </span>def <span class="kw">inorderTraversal</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="st">        </span><span class="cf">if</span> root <span class="op">==</span><span class="st"> </span>None<span class="op">:</span><span class="st"> </span>如果节点不存在</span>
<span id="cb16-11"><a href="#cb16-11"></a>            return []</span>
<span id="cb16-12"><a href="#cb16-12"></a>        left =<span class="st"> </span><span class="kw">self.inorderTraversal</span>(root.left)</span>
<span id="cb16-13"><a href="#cb16-13"></a>        right =<span class="st"> </span><span class="kw">self.inorderTraversal</span>(root.right)</span>
<span id="cb16-14"><a href="#cb16-14"></a>        return left <span class="op">+</span><span class="st"> </span>[root.val] <span class="op">+</span><span class="st"> </span>right <span class="co">#输出的时候把顺序变一下子</span></span></code></pre></div>
</div>
<div id="二叉树的层次遍历-1" class="section level2" number="0.4">
<h2 number="0.4"><span class="header-section-number">0.4</span> 二叉树的层次遍历</h2>
<p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如: 给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3</code></pre>
<p>/<br />
9 20
/<br />
15 7
返回其层次遍历结果：
[
[3],
[9,20],
[15,7]]</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a></span>
<span id="cb18-2"><a href="#cb18-2"></a>class Solution<span class="op">:</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="st">    </span>def <span class="kw">levelOrder</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[List[int]]<span class="op">:</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="st">        </span><span class="cf">if</span> root <span class="op">==</span><span class="st"> </span>None<span class="op">:</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="st">            </span>return []</span>
<span id="cb18-6"><a href="#cb18-6"></a>        layer =<span class="st"> </span>[root]  <span class="co">#定义当前层</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>        res =<span class="st"> </span>[] <span class="co">#保存结果的数组</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>        <span class="cf">while</span> <span class="kw">len</span>(layer)<span class="op">:</span><span class="st"> </span></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="st">            </span>this_res =<span class="st"> </span>[] <span class="co">#当前层的结果</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>            next_l =<span class="st"> </span>[] <span class="co">#下一层的结果</span></span>
<span id="cb18-11"><a href="#cb18-11"></a>            <span class="cf">for</span> n <span class="cf">in</span> layer<span class="op">:</span></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="st">                </span><span class="kw">this_res.append</span>(n.val)</span>
<span id="cb18-13"><a href="#cb18-13"></a>                <span class="cf">if</span> n.left<span class="op">:</span><span class="st"> </span><span class="co"># 左右孩子都在下一层</span></span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="st">                    </span><span class="kw">next_l.append</span>(n.left)</span>
<span id="cb18-15"><a href="#cb18-15"></a>                <span class="cf">if</span> n.right<span class="op">:</span></span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="st">                    </span><span class="kw">next_l.append</span>(n.right)</span>
<span id="cb18-17"><a href="#cb18-17"></a>            <span class="kw">res.append</span>(this_res)</span>
<span id="cb18-18"><a href="#cb18-18"></a>            layer =<span class="st"> </span>next_l</span>
<span id="cb18-19"><a href="#cb18-19"></a>        return res</span></code></pre></div>
</div>
<div id="前序中序后序遍历" class="section level2" number="0.5">
<h2 number="0.5"><span class="header-section-number">0.5</span> 前序中序后序遍历</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>class TreeNode<span class="op">:</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="st">    </span>def <span class="kw">__init__</span>(self, x)<span class="op">:</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="st">        </span>self.val =<span class="st"> </span>x</span>
<span id="cb19-4"><a href="#cb19-4"></a>        self.left =<span class="st"> </span>None</span>
<span id="cb19-5"><a href="#cb19-5"></a>        self.right =<span class="st"> </span>None</span>
<span id="cb19-6"><a href="#cb19-6"></a>class Solution<span class="op">:</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="st">    </span><span class="co">#前序</span></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="st">    </span>def <span class="kw">preorder</span>(self,root,<span class="dt">ans=</span>[])<span class="op">:</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="st">        </span><span class="cf">if</span> root<span class="op">!=</span>None<span class="op">:</span></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="st">            </span><span class="kw">ans.append</span>(root.val)</span>
<span id="cb19-11"><a href="#cb19-11"></a>        <span class="cf">if</span> root.left<span class="op">:</span></span>
<span id="cb19-12"><a href="#cb19-12"></a><span class="st">            </span><span class="kw">self.preorder</span>(root.left,ans)</span>
<span id="cb19-13"><a href="#cb19-13"></a>        <span class="cf">if</span> root.right<span class="op">:</span></span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="st">            </span><span class="kw">self.preorder</span>(root.right,ans)</span>
<span id="cb19-15"><a href="#cb19-15"></a>        return ans</span>
<span id="cb19-16"><a href="#cb19-16"></a>    </span>
<span id="cb19-17"><a href="#cb19-17"></a>    <span class="co">#中序</span></span>
<span id="cb19-18"><a href="#cb19-18"></a>    def <span class="kw">inorder</span>(self,root,<span class="dt">ans=</span>[])<span class="op">:</span></span>
<span id="cb19-19"><a href="#cb19-19"></a><span class="st">        </span><span class="co"># if root.left==None and root.right==None:</span></span>
<span id="cb19-20"><a href="#cb19-20"></a><span class="st">        </span><span class="co">#     ans.append(root.val)</span></span>
<span id="cb19-21"><a href="#cb19-21"></a><span class="st">        </span><span class="co">#     return</span></span>
<span id="cb19-22"><a href="#cb19-22"></a><span class="st">        </span><span class="cf">if</span> root.left<span class="op">:</span></span>
<span id="cb19-23"><a href="#cb19-23"></a><span class="st">            </span><span class="kw">self.inorder</span>(root.left,ans)</span>
<span id="cb19-24"><a href="#cb19-24"></a>        <span class="kw">ans.append</span>(root.val)</span>
<span id="cb19-25"><a href="#cb19-25"></a>        <span class="cf">if</span> root.right<span class="op">:</span></span>
<span id="cb19-26"><a href="#cb19-26"></a><span class="st">            </span><span class="kw">self.inorder</span>(root.right,ans)</span>
<span id="cb19-27"><a href="#cb19-27"></a>        return ans</span>
<span id="cb19-28"><a href="#cb19-28"></a>    </span>
<span id="cb19-29"><a href="#cb19-29"></a>    <span class="co">#后序</span></span>
<span id="cb19-30"><a href="#cb19-30"></a>    def <span class="kw">postorder</span>(self,root,<span class="dt">ans=</span>[])<span class="op">:</span></span>
<span id="cb19-31"><a href="#cb19-31"></a><span class="st">        </span><span class="cf">if</span> root.left<span class="op">:</span></span>
<span id="cb19-32"><a href="#cb19-32"></a><span class="st">            </span><span class="kw">self.postorder</span>(root.left,ans)</span>
<span id="cb19-33"><a href="#cb19-33"></a>        <span class="cf">if</span> root.right<span class="op">:</span></span>
<span id="cb19-34"><a href="#cb19-34"></a><span class="st">            </span><span class="kw">self.postorder</span>(root.right,ans)</span>
<span id="cb19-35"><a href="#cb19-35"></a>        <span class="kw">ans.append</span>(root.val)</span>
<span id="cb19-36"><a href="#cb19-36"></a>        return ans</span>
<span id="cb19-37"><a href="#cb19-37"></a>        </span></code></pre></div>
</div>
<div id="堆排序" class="section level2" number="0.6">
<h2 number="0.6"><span class="header-section-number">0.6</span> 堆排序</h2>
<p>树遍历的思想</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
待补充</li>
</ul>
</div>
<div id="霍夫曼树" class="section level2" number="0.7">
<h2 number="0.7"><span class="header-section-number">0.7</span> 霍夫曼树</h2>
<p>遍历树的思想真的挺重要的，后面的word2vec，fasttext等预训练模型都用到霍夫曼树的思想进行优化，提升训练速度。</p>
</div>
<div id="二叉树遍历总结" class="section level2" number="0.8">
<h2 number="0.8"><span class="header-section-number">0.8</span> 二叉树遍历总结</h2>
<p>参考<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/python3-er-cha-shu-suo-you-bian-li-mo-ban-ji-zhi-s/">【作者：821218213】</a></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># Definition for a binary tree node.</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="co"># class TreeNode:</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="co">#     def __init__(self, x):</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co">#         self.val = x</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="co">#         self.left = None</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="co">#         self.right = None</span></span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="co"># 递归</span></span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="co"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="co"># 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)</span></span>
<span id="cb20-13"><a href="#cb20-13"></a></span>
<span id="cb20-14"><a href="#cb20-14"></a></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="co"># 递归1：二叉树遍历最易理解和实现版本</span></span>
<span id="cb20-16"><a href="#cb20-16"></a>class Solution<span class="op">:</span></span>
<span id="cb20-17"><a href="#cb20-17"></a><span class="st">    </span>def <span class="kw">preorderTraversal</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb20-18"><a href="#cb20-18"></a><span class="st">        </span><span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb20-19"><a href="#cb20-19"></a><span class="st">            </span>return []</span>
<span id="cb20-20"><a href="#cb20-20"></a>        <span class="co"># 前序递归</span></span>
<span id="cb20-21"><a href="#cb20-21"></a>        return [root.val] <span class="op">+</span><span class="st"> </span><span class="kw">self.preorderTraversal</span>(root.left) <span class="op">+</span><span class="st"> </span><span class="kw">self.preorderTraversal</span>(root.right)</span>
<span id="cb20-22"><a href="#cb20-22"></a>        <span class="co"># # 中序递归 </span></span>
<span id="cb20-23"><a href="#cb20-23"></a>        <span class="co"># return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span></span>
<span id="cb20-24"><a href="#cb20-24"></a>        <span class="co"># # 后序递归</span></span>
<span id="cb20-25"><a href="#cb20-25"></a>        <span class="co"># return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]</span></span>
<span id="cb20-26"><a href="#cb20-26"></a></span>
<span id="cb20-27"><a href="#cb20-27"></a><span class="co"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span></span>
<span id="cb20-28"><a href="#cb20-28"></a>class Solution<span class="op">:</span></span>
<span id="cb20-29"><a href="#cb20-29"></a><span class="st">    </span>def <span class="kw">preorderTraversal</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb20-30"><a href="#cb20-30"></a><span class="st">        </span>def <span class="kw">dfs</span>(cur)<span class="op">:</span></span>
<span id="cb20-31"><a href="#cb20-31"></a><span class="st">            </span><span class="cf">if</span> not cur<span class="op">:</span></span>
<span id="cb20-32"><a href="#cb20-32"></a><span class="st">                </span>return      </span>
<span id="cb20-33"><a href="#cb20-33"></a>            <span class="co"># 前序递归</span></span>
<span id="cb20-34"><a href="#cb20-34"></a>            <span class="kw">res.append</span>(cur.val)</span>
<span id="cb20-35"><a href="#cb20-35"></a>            <span class="kw">dfs</span>(cur.left)</span>
<span id="cb20-36"><a href="#cb20-36"></a>            <span class="kw">dfs</span>(cur.right) </span>
<span id="cb20-37"><a href="#cb20-37"></a>            <span class="co"># # 中序递归</span></span>
<span id="cb20-38"><a href="#cb20-38"></a>            <span class="co"># dfs(cur.left)</span></span>
<span id="cb20-39"><a href="#cb20-39"></a>            <span class="co"># res.append(cur.val)</span></span>
<span id="cb20-40"><a href="#cb20-40"></a>            <span class="co"># dfs(cur.right)</span></span>
<span id="cb20-41"><a href="#cb20-41"></a>            <span class="co"># # 后序递归</span></span>
<span id="cb20-42"><a href="#cb20-42"></a>            <span class="co"># dfs(cur.left)</span></span>
<span id="cb20-43"><a href="#cb20-43"></a>            <span class="co"># dfs(cur.right)</span></span>
<span id="cb20-44"><a href="#cb20-44"></a>            <span class="co"># res.append(cur.val)      </span></span>
<span id="cb20-45"><a href="#cb20-45"></a>        res =<span class="st"> </span>[]</span>
<span id="cb20-46"><a href="#cb20-46"></a>        <span class="kw">dfs</span>(root)</span>
<span id="cb20-47"><a href="#cb20-47"></a>        return res</span>
<span id="cb20-48"><a href="#cb20-48"></a></span>
<span id="cb20-49"><a href="#cb20-49"></a></span>
<span id="cb20-50"><a href="#cb20-50"></a></span>
<span id="cb20-51"><a href="#cb20-51"></a><span class="co"># 迭代</span></span>
<span id="cb20-52"><a href="#cb20-52"></a><span class="co"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span>
<span id="cb20-53"><a href="#cb20-53"></a><span class="co"># 空间复杂度：O(h)，h为树的高度。取决于树的结构，最坏情况存储整棵树，即O(n)</span></span>
<span id="cb20-54"><a href="#cb20-54"></a></span>
<span id="cb20-55"><a href="#cb20-55"></a><span class="co"># 迭代1：前序遍历最常用模板（后序同样可以用）</span></span>
<span id="cb20-56"><a href="#cb20-56"></a>class Solution<span class="op">:</span></span>
<span id="cb20-57"><a href="#cb20-57"></a><span class="st">    </span>def <span class="kw">preorderTraversal</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb20-58"><a href="#cb20-58"></a><span class="st">        </span><span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb20-59"><a href="#cb20-59"></a><span class="st">            </span>return []        </span>
<span id="cb20-60"><a href="#cb20-60"></a>        res =<span class="st"> </span>[]</span>
<span id="cb20-61"><a href="#cb20-61"></a>        stack =<span class="st"> </span>[root]</span>
<span id="cb20-62"><a href="#cb20-62"></a>        <span class="co"># # 前序迭代模板：最常用的二叉树DFS迭代遍历模板</span></span>
<span id="cb20-63"><a href="#cb20-63"></a>        <span class="cf">while</span> stack<span class="op">:</span></span>
<span id="cb20-64"><a href="#cb20-64"></a><span class="st">            </span>cur =<span class="st"> </span><span class="kw">stack.pop</span>()</span>
<span id="cb20-65"><a href="#cb20-65"></a>            <span class="kw">res.append</span>(cur.val)</span>
<span id="cb20-66"><a href="#cb20-66"></a>            <span class="cf">if</span> cur.right<span class="op">:</span></span>
<span id="cb20-67"><a href="#cb20-67"></a><span class="st">                </span><span class="kw">stack.append</span>(cur.right)</span>
<span id="cb20-68"><a href="#cb20-68"></a>            <span class="cf">if</span> cur.left<span class="op">:</span></span>
<span id="cb20-69"><a href="#cb20-69"></a><span class="st">                </span><span class="kw">stack.append</span>(cur.left)</span>
<span id="cb20-70"><a href="#cb20-70"></a>        return res</span>
<span id="cb20-71"><a href="#cb20-71"></a>        </span>
<span id="cb20-72"><a href="#cb20-72"></a>        <span class="co"># # 后序迭代，相同模板：将前序迭代进栈顺序稍作修改，最后得到的结果反转</span></span>
<span id="cb20-73"><a href="#cb20-73"></a>        <span class="co"># while stack:</span></span>
<span id="cb20-74"><a href="#cb20-74"></a>        <span class="co">#     cur = stack.pop()</span></span>
<span id="cb20-75"><a href="#cb20-75"></a>        <span class="co">#     if cur.left:</span></span>
<span id="cb20-76"><a href="#cb20-76"></a>        <span class="co">#         stack.append(cur.left)</span></span>
<span id="cb20-77"><a href="#cb20-77"></a>        <span class="co">#     if cur.right:</span></span>
<span id="cb20-78"><a href="#cb20-78"></a>        <span class="co">#         stack.append(cur.right)</span></span>
<span id="cb20-79"><a href="#cb20-79"></a>        <span class="co">#     res.append(cur.val)</span></span>
<span id="cb20-80"><a href="#cb20-80"></a>        <span class="co"># return res[::-1]</span></span>
<span id="cb20-81"><a href="#cb20-81"></a></span>
<span id="cb20-82"><a href="#cb20-82"></a><span class="co"># 迭代1：层序遍历最常用模板</span></span>
<span id="cb20-83"><a href="#cb20-83"></a>class Solution<span class="op">:</span></span>
<span id="cb20-84"><a href="#cb20-84"></a><span class="st">    </span>def <span class="kw">levelOrder</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[List[int]]<span class="op">:</span></span>
<span id="cb20-85"><a href="#cb20-85"></a><span class="st">        </span><span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb20-86"><a href="#cb20-86"></a><span class="st">            </span>return []</span>
<span id="cb20-87"><a href="#cb20-87"></a>        cur, res =<span class="st"> </span>[root], []</span>
<span id="cb20-88"><a href="#cb20-88"></a>        <span class="cf">while</span> cur<span class="op">:</span></span>
<span id="cb20-89"><a href="#cb20-89"></a><span class="st">            </span>lay, layval =<span class="st"> </span>[], []</span>
<span id="cb20-90"><a href="#cb20-90"></a>            <span class="cf">for</span> node <span class="cf">in</span> cur<span class="op">:</span></span>
<span id="cb20-91"><a href="#cb20-91"></a><span class="st">                </span><span class="kw">layval.append</span>(node.val)</span>
<span id="cb20-92"><a href="#cb20-92"></a>                <span class="cf">if</span> node.left<span class="op">:</span><span class="st"> </span><span class="kw">lay.append</span>(node.left)</span>
<span id="cb20-93"><a href="#cb20-93"></a>                <span class="cf">if</span> node.right<span class="op">:</span><span class="st"> </span><span class="kw">lay.append</span>(node.right)</span>
<span id="cb20-94"><a href="#cb20-94"></a>            cur =<span class="st"> </span>lay</span>
<span id="cb20-95"><a href="#cb20-95"></a>            <span class="kw">res.append</span>(layval)</span>
<span id="cb20-96"><a href="#cb20-96"></a>        return res</span>
<span id="cb20-97"><a href="#cb20-97"></a></span>
<span id="cb20-98"><a href="#cb20-98"></a>        </span>
<span id="cb20-99"><a href="#cb20-99"></a>        </span>
<span id="cb20-100"><a href="#cb20-100"></a><span class="co"># 迭代2：前、中、后序遍历通用模板（只需一个栈的空间）</span></span>
<span id="cb20-101"><a href="#cb20-101"></a>class Solution<span class="op">:</span></span>
<span id="cb20-102"><a href="#cb20-102"></a><span class="st">    </span>def <span class="kw">inorderTraversal</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[int]<span class="op">:</span><span class="st"> </span></span>
<span id="cb20-103"><a href="#cb20-103"></a><span class="st">        </span>res =<span class="st"> </span>[]</span>
<span id="cb20-104"><a href="#cb20-104"></a>        stack =<span class="st"> </span>[]</span>
<span id="cb20-105"><a href="#cb20-105"></a>        cur =<span class="st"> </span>root</span>
<span id="cb20-106"><a href="#cb20-106"></a>        <span class="co"># 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作</span></span>
<span id="cb20-107"><a href="#cb20-107"></a>        <span class="cf">while</span> stack or cur<span class="op">:</span></span>
<span id="cb20-108"><a href="#cb20-108"></a><span class="st">            </span><span class="cf">while</span> cur<span class="op">:</span></span>
<span id="cb20-109"><a href="#cb20-109"></a><span class="st">                </span><span class="kw">stack.append</span>(cur)</span>
<span id="cb20-110"><a href="#cb20-110"></a>                cur =<span class="st"> </span>cur.left</span>
<span id="cb20-111"><a href="#cb20-111"></a>            cur =<span class="st"> </span><span class="kw">stack.pop</span>()</span>
<span id="cb20-112"><a href="#cb20-112"></a>            <span class="kw">res.append</span>(cur.val)</span>
<span id="cb20-113"><a href="#cb20-113"></a>            cur =<span class="st"> </span>cur.right</span>
<span id="cb20-114"><a href="#cb20-114"></a>        return res</span>
<span id="cb20-115"><a href="#cb20-115"></a>        </span>
<span id="cb20-116"><a href="#cb20-116"></a>        <span class="co"># # 前序，相同模板</span></span>
<span id="cb20-117"><a href="#cb20-117"></a>        <span class="co"># while stack or cur:</span></span>
<span id="cb20-118"><a href="#cb20-118"></a>        <span class="co">#     while cur:</span></span>
<span id="cb20-119"><a href="#cb20-119"></a>        <span class="co">#         res.append(cur.val)</span></span>
<span id="cb20-120"><a href="#cb20-120"></a>        <span class="co">#         stack.append(cur)</span></span>
<span id="cb20-121"><a href="#cb20-121"></a>        <span class="co">#         cur = cur.left</span></span>
<span id="cb20-122"><a href="#cb20-122"></a>        <span class="co">#     cur = stack.pop()</span></span>
<span id="cb20-123"><a href="#cb20-123"></a>        <span class="co">#     cur = cur.right</span></span>
<span id="cb20-124"><a href="#cb20-124"></a>        <span class="co"># return res</span></span>
<span id="cb20-125"><a href="#cb20-125"></a>        </span>
<span id="cb20-126"><a href="#cb20-126"></a>        <span class="co"># # 后序，相同模板</span></span>
<span id="cb20-127"><a href="#cb20-127"></a>        <span class="co"># while stack or cur:</span></span>
<span id="cb20-128"><a href="#cb20-128"></a>        <span class="co">#     while cur:</span></span>
<span id="cb20-129"><a href="#cb20-129"></a>        <span class="co">#         res.append(cur.val)</span></span>
<span id="cb20-130"><a href="#cb20-130"></a>        <span class="co">#         stack.append(cur)</span></span>
<span id="cb20-131"><a href="#cb20-131"></a>        <span class="co">#         cur = cur.right</span></span>
<span id="cb20-132"><a href="#cb20-132"></a>        <span class="co">#     cur = stack.pop()</span></span>
<span id="cb20-133"><a href="#cb20-133"></a>        <span class="co">#     cur = cur.left</span></span>
<span id="cb20-134"><a href="#cb20-134"></a>        <span class="co"># return res[::-1]</span></span>
<span id="cb20-135"><a href="#cb20-135"></a>        </span>
<span id="cb20-136"><a href="#cb20-136"></a></span>
<span id="cb20-137"><a href="#cb20-137"></a></span>
<span id="cb20-138"><a href="#cb20-138"></a><span class="co"># 迭代3：标记法迭代（需要双倍的空间来存储访问状态）：</span></span>
<span id="cb20-139"><a href="#cb20-139"></a><span class="co"># 前、中、后、层序通用模板，只需改变进栈顺序或即可实现前后中序遍历，</span></span>
<span id="cb20-140"><a href="#cb20-140"></a><span class="co"># 而层序遍历则使用队列先进先出。0表示当前未访问，1表示已访问。</span></span>
<span id="cb20-141"><a href="#cb20-141"></a>class Solution<span class="op">:</span></span>
<span id="cb20-142"><a href="#cb20-142"></a><span class="st">    </span>def <span class="kw">preorderTraversal</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb20-143"><a href="#cb20-143"></a><span class="st">        </span>res =<span class="st"> </span>[]</span>
<span id="cb20-144"><a href="#cb20-144"></a>        stack =<span class="st"> </span>[(<span class="dv">0</span>, root)]</span>
<span id="cb20-145"><a href="#cb20-145"></a>        <span class="cf">while</span> stack<span class="op">:</span></span>
<span id="cb20-146"><a href="#cb20-146"></a><span class="st">            </span>flag, cur =<span class="st"> </span><span class="kw">stack.pop</span>()</span>
<span id="cb20-147"><a href="#cb20-147"></a>            <span class="cf">if</span> not cur<span class="op">:</span><span class="st"> </span>continue</span>
<span id="cb20-148"><a href="#cb20-148"></a>            <span class="cf">if</span> flag <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb20-149"><a href="#cb20-149"></a><span class="st">                </span><span class="co"># 前序，标记法</span></span>
<span id="cb20-150"><a href="#cb20-150"></a><span class="st">                </span><span class="kw">stack.append</span>((<span class="dv">0</span>, cur.right))</span>
<span id="cb20-151"><a href="#cb20-151"></a>                <span class="kw">stack.append</span>((<span class="dv">0</span>, cur.left))</span>
<span id="cb20-152"><a href="#cb20-152"></a>                <span class="kw">stack.append</span>((<span class="dv">1</span>, cur))</span>
<span id="cb20-153"><a href="#cb20-153"></a>                </span>
<span id="cb20-154"><a href="#cb20-154"></a>                <span class="co"># # 后序，标记法</span></span>
<span id="cb20-155"><a href="#cb20-155"></a>                <span class="co"># stack.append((1, cur))</span></span>
<span id="cb20-156"><a href="#cb20-156"></a>                <span class="co"># stack.append((0, cur.right))</span></span>
<span id="cb20-157"><a href="#cb20-157"></a>                <span class="co"># stack.append((0, cur.left))</span></span>
<span id="cb20-158"><a href="#cb20-158"></a>                </span>
<span id="cb20-159"><a href="#cb20-159"></a>                <span class="co"># # 中序，标记法</span></span>
<span id="cb20-160"><a href="#cb20-160"></a>                <span class="co"># stack.append((0, cur.right))</span></span>
<span id="cb20-161"><a href="#cb20-161"></a>                <span class="co"># stack.append((1, cur))</span></span>
<span id="cb20-162"><a href="#cb20-162"></a>                <span class="co"># stack.append((0, cur.left))  </span></span>
<span id="cb20-163"><a href="#cb20-163"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb20-164"><a href="#cb20-164"></a><span class="st">                </span><span class="kw">res.append</span>(cur.val)  </span>
<span id="cb20-165"><a href="#cb20-165"></a>        return res</span>
<span id="cb20-166"><a href="#cb20-166"></a>        </span>
<span id="cb20-167"><a href="#cb20-167"></a>        <span class="co"># # 层序，标记法</span></span>
<span id="cb20-168"><a href="#cb20-168"></a>        <span class="co"># res = []</span></span>
<span id="cb20-169"><a href="#cb20-169"></a>        <span class="co"># queue = [(0, root)]</span></span>
<span id="cb20-170"><a href="#cb20-170"></a>        <span class="co"># while queue:</span></span>
<span id="cb20-171"><a href="#cb20-171"></a>        <span class="co">#     flag, cur = queue.pop(0)  # 注意是队列，先进先出</span></span>
<span id="cb20-172"><a href="#cb20-172"></a>        <span class="co">#     if not cur: continue</span></span>
<span id="cb20-173"><a href="#cb20-173"></a>        <span class="co">#     if flag == 0:</span></span>
<span id="cb20-174"><a href="#cb20-174"></a>                  <span class="co"># 层序遍历这三个的顺序无所谓，因为是队列，只弹出队首元素</span></span>
<span id="cb20-175"><a href="#cb20-175"></a>        <span class="co">#         queue.append((1, cur))</span></span>
<span id="cb20-176"><a href="#cb20-176"></a>        <span class="co">#         queue.append((0, cur.left))</span></span>
<span id="cb20-177"><a href="#cb20-177"></a>        <span class="co">#         queue.append((0, cur.right))</span></span>
<span id="cb20-178"><a href="#cb20-178"></a>        <span class="co">#     else:</span></span>
<span id="cb20-179"><a href="#cb20-179"></a>        <span class="co">#         res.append(cur.val)</span></span>
<span id="cb20-180"><a href="#cb20-180"></a>        <span class="co"># return res</span></span>
<span id="cb20-181"><a href="#cb20-181"></a></span>
<span id="cb20-182"><a href="#cb20-182"></a></span>
<span id="cb20-183"><a href="#cb20-183"></a></span>
<span id="cb20-184"><a href="#cb20-184"></a><span class="co"># 莫里斯遍历</span></span>
<span id="cb20-185"><a href="#cb20-185"></a><span class="co"># 时间复杂度：O(n)，n为节点数，看似超过O(n)，有的节点可能要访问两次，实际分析还是O(n)，具体参考大佬博客的分析。</span></span>
<span id="cb20-186"><a href="#cb20-186"></a><span class="co"># 空间复杂度：O(1)，如果在遍历过程中就输出节点值，则只需常数空间就能得到中序遍历结果，空间只需两个指针。</span></span>
<span id="cb20-187"><a href="#cb20-187"></a><span class="co"># 如果将结果储存最后输出，则空间复杂度还是O(n)。</span></span>
<span id="cb20-188"><a href="#cb20-188"></a></span>
<span id="cb20-189"><a href="#cb20-189"></a><span class="co"># PS：莫里斯遍历实际上是在原有二叉树的结构基础上，构造了线索二叉树，</span></span>
<span id="cb20-190"><a href="#cb20-190"></a><span class="co"># 线索二叉树定义为：原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点</span></span>
<span id="cb20-191"><a href="#cb20-191"></a><span class="co"># emmmm，好像大学教材学过，还考过</span></span>
<span id="cb20-192"><a href="#cb20-192"></a></span>
<span id="cb20-193"><a href="#cb20-193"></a><span class="co"># 此处只给出中序遍历，前序遍历只需修改输出顺序即可</span></span>
<span id="cb20-194"><a href="#cb20-194"></a><span class="co"># 而后序遍历，由于遍历是从根开始的，而线索二叉树是将为空的左右子节点连接到相应的顺序上，使其能够按照相应准则输出</span></span>
<span id="cb20-195"><a href="#cb20-195"></a><span class="co"># 但是后序遍历的根节点却已经没有额外的空间来标记自己下一个应该访问的节点，</span></span>
<span id="cb20-196"><a href="#cb20-196"></a><span class="co"># 所以这里需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。</span></span>
<span id="cb20-197"><a href="#cb20-197"></a><span class="co"># 具体参考大佬博客</span></span>
<span id="cb20-198"><a href="#cb20-198"></a></span>
<span id="cb20-199"><a href="#cb20-199"></a><span class="co"># 莫里斯遍历，借助线索二叉树中序遍历（附前序遍历）</span></span>
<span id="cb20-200"><a href="#cb20-200"></a>class Solution<span class="op">:</span></span>
<span id="cb20-201"><a href="#cb20-201"></a><span class="st">    </span>def <span class="kw">inorderTraversal</span>(self, root<span class="op">:</span><span class="st"> </span>TreeNode) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb20-202"><a href="#cb20-202"></a><span class="st">        </span>res =<span class="st"> </span>[]</span>
<span id="cb20-203"><a href="#cb20-203"></a>        <span class="co"># cur = pre = TreeNode(None)</span></span>
<span id="cb20-204"><a href="#cb20-204"></a>        cur =<span class="st"> </span>root</span>
<span id="cb20-205"><a href="#cb20-205"></a></span>
<span id="cb20-206"><a href="#cb20-206"></a>        <span class="cf">while</span> cur<span class="op">:</span></span>
<span id="cb20-207"><a href="#cb20-207"></a><span class="st">            </span><span class="cf">if</span> not cur.left<span class="op">:</span></span>
<span id="cb20-208"><a href="#cb20-208"></a><span class="st">                </span><span class="kw">res.append</span>(cur.val)</span>
<span id="cb20-209"><a href="#cb20-209"></a>                <span class="co"># print(cur.val)</span></span>
<span id="cb20-210"><a href="#cb20-210"></a>                cur =<span class="st"> </span>cur.right</span>
<span id="cb20-211"><a href="#cb20-211"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb20-212"><a href="#cb20-212"></a><span class="st">                </span>pre =<span class="st"> </span>cur.left</span>
<span id="cb20-213"><a href="#cb20-213"></a>                <span class="cf">while</span> pre.right and pre.right <span class="op">!=</span><span class="st"> </span>cur<span class="op">:</span></span>
<span id="cb20-214"><a href="#cb20-214"></a><span class="st">                    </span>pre =<span class="st"> </span>pre.right</span>
<span id="cb20-215"><a href="#cb20-215"></a>                <span class="cf">if</span> not pre.right<span class="op">:</span></span>
<span id="cb20-216"><a href="#cb20-216"></a><span class="st">                    </span><span class="co"># print(cur.val) 这里是前序遍历的代码，前序与中序的唯一差别，只是输出顺序不同</span></span>
<span id="cb20-217"><a href="#cb20-217"></a><span class="st">                    </span>pre.right =<span class="st"> </span>cur</span>
<span id="cb20-218"><a href="#cb20-218"></a>                    cur =<span class="st"> </span>cur.left</span>
<span id="cb20-219"><a href="#cb20-219"></a>                <span class="cf">else</span><span class="op">:</span></span>
<span id="cb20-220"><a href="#cb20-220"></a><span class="st">                    </span>pre.right =<span class="st"> </span>None</span>
<span id="cb20-221"><a href="#cb20-221"></a>                    <span class="kw">res.append</span>(cur.val)</span>
<span id="cb20-222"><a href="#cb20-222"></a>                    <span class="co"># print(cur.val)</span></span>
<span id="cb20-223"><a href="#cb20-223"></a>                    cur =<span class="st"> </span>cur.right</span>
<span id="cb20-224"><a href="#cb20-224"></a>        return res</span>
<span id="cb20-225"><a href="#cb20-225"></a></span>
<span id="cb20-226"><a href="#cb20-226"></a></span>
<span id="cb20-227"><a href="#cb20-227"></a></span>
<span id="cb20-228"><a href="#cb20-228"></a><span class="co"># N叉树遍历</span></span>
<span id="cb20-229"><a href="#cb20-229"></a><span class="co"># 时间复杂度：时间复杂度：O(M)，其中 M 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。</span></span>
<span id="cb20-230"><a href="#cb20-230"></a><span class="co"># 空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。</span></span>
<span id="cb20-231"><a href="#cb20-231"></a><span class="co"># 将根节点推出栈后，需要将这些节点都放入栈，共有 M−1个节点，因此栈的大小为 O(M)。</span></span>
<span id="cb20-232"><a href="#cb20-232"></a></span>
<span id="cb20-233"><a href="#cb20-233"></a></span>
<span id="cb20-234"><a href="#cb20-234"></a><span class="st">&quot;&quot;&quot;</span></span>
<span id="cb20-235"><a href="#cb20-235"></a><span class="st"># Definition for a Node.</span></span>
<span id="cb20-236"><a href="#cb20-236"></a><span class="st">class Node:</span></span>
<span id="cb20-237"><a href="#cb20-237"></a><span class="st">    def __init__(self, val=None, children=None):</span></span>
<span id="cb20-238"><a href="#cb20-238"></a><span class="st">        self.val = val</span></span>
<span id="cb20-239"><a href="#cb20-239"></a><span class="st">        self.children = children</span></span>
<span id="cb20-240"><a href="#cb20-240"></a><span class="st">&quot;&quot;&quot;</span></span>
<span id="cb20-241"><a href="#cb20-241"></a></span>
<span id="cb20-242"><a href="#cb20-242"></a><span class="co"># N叉树简洁递归</span></span>
<span id="cb20-243"><a href="#cb20-243"></a>class Solution<span class="op">:</span></span>
<span id="cb20-244"><a href="#cb20-244"></a><span class="st">    </span>def <span class="kw">preorder</span>(self, root<span class="op">:</span><span class="st"> &#39;Node&#39;</span>) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb20-245"><a href="#cb20-245"></a><span class="st">        </span><span class="cf">if</span> not root<span class="op">:</span><span class="st"> </span>return []</span>
<span id="cb20-246"><a href="#cb20-246"></a>        res =<span class="st"> </span>[root.val]</span>
<span id="cb20-247"><a href="#cb20-247"></a>        <span class="cf">for</span> node <span class="cf">in</span> root.children<span class="op">:</span></span>
<span id="cb20-248"><a href="#cb20-248"></a><span class="st">            </span><span class="kw">res.extend</span>(<span class="kw">self.preorder</span>(node))</span>
<span id="cb20-249"><a href="#cb20-249"></a>        return res</span>
<span id="cb20-250"><a href="#cb20-250"></a></span>
<span id="cb20-251"><a href="#cb20-251"></a><span class="co"># N叉树通用递归模板</span></span>
<span id="cb20-252"><a href="#cb20-252"></a>class Solution<span class="op">:</span></span>
<span id="cb20-253"><a href="#cb20-253"></a><span class="st">    </span>def <span class="kw">preorder</span>(self, root<span class="op">:</span><span class="st"> &#39;Node&#39;</span>) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb20-254"><a href="#cb20-254"></a><span class="st">        </span>res =<span class="st"> </span>[]</span>
<span id="cb20-255"><a href="#cb20-255"></a>        def <span class="kw">helper</span>(root)<span class="op">:</span></span>
<span id="cb20-256"><a href="#cb20-256"></a><span class="st">            </span><span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb20-257"><a href="#cb20-257"></a><span class="st">                </span>return</span>
<span id="cb20-258"><a href="#cb20-258"></a>            <span class="kw">res.append</span>(root.val)</span>
<span id="cb20-259"><a href="#cb20-259"></a>            <span class="cf">for</span> child <span class="cf">in</span> root.children<span class="op">:</span></span>
<span id="cb20-260"><a href="#cb20-260"></a><span class="st">                </span><span class="kw">helper</span>(child)</span>
<span id="cb20-261"><a href="#cb20-261"></a>        <span class="kw">helper</span>(root)</span>
<span id="cb20-262"><a href="#cb20-262"></a>        return res</span>
<span id="cb20-263"><a href="#cb20-263"></a></span>
<span id="cb20-264"><a href="#cb20-264"></a><span class="co"># N叉树迭代方法</span></span>
<span id="cb20-265"><a href="#cb20-265"></a>class Solution<span class="op">:</span></span>
<span id="cb20-266"><a href="#cb20-266"></a><span class="st">    </span>def <span class="kw">preorder</span>(self, root<span class="op">:</span><span class="st"> &#39;Node&#39;</span>) -&gt;<span class="st"> </span>List[int]<span class="op">:</span></span>
<span id="cb20-267"><a href="#cb20-267"></a><span class="st">        </span><span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb20-268"><a href="#cb20-268"></a><span class="st">            </span>return []</span>
<span id="cb20-269"><a href="#cb20-269"></a>        s =<span class="st"> </span>[root]</span>
<span id="cb20-270"><a href="#cb20-270"></a>        <span class="co"># s.append(root)</span></span>
<span id="cb20-271"><a href="#cb20-271"></a>        res =<span class="st"> </span>[]</span>
<span id="cb20-272"><a href="#cb20-272"></a>        <span class="cf">while</span> s<span class="op">:</span></span>
<span id="cb20-273"><a href="#cb20-273"></a><span class="st">            </span>node =<span class="st"> </span><span class="kw">s.pop</span>()</span>
<span id="cb20-274"><a href="#cb20-274"></a>            <span class="kw">res.append</span>(node.val)</span>
<span id="cb20-275"><a href="#cb20-275"></a>            <span class="co"># for child in node.children[::-1]:</span></span>
<span id="cb20-276"><a href="#cb20-276"></a>            <span class="co">#     s.append(child)</span></span>
<span id="cb20-277"><a href="#cb20-277"></a>            <span class="kw">s.extend</span>(node.children[<span class="op">::-</span><span class="dv">1</span>])</span>
<span id="cb20-278"><a href="#cb20-278"></a>        return res</span></code></pre></div>
</div>
<!--bookdown:body:end-->
            </section>

          </div>
        </div>
      </div>
<!--bookdown:link_prev-->
<!--bookdown:link_next-->
    </div>
  </div>
<!--bookdown:config-->

</body>

</html>
